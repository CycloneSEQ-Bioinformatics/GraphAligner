// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vg.proto

#ifndef PROTOBUF_vg_2eproto__INCLUDED
#define PROTOBUF_vg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace vg {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_vg_2eproto();
void protobuf_AssignDesc_vg_2eproto();
void protobuf_ShutdownFile_vg_2eproto();

class Alignment;
class BasePileup;
class Edge;
class EdgePileup;
class Edit;
class Genotype;
class Graph;
class KmerMatch;
class Locus;
class Mapping;
class MultipathAlignment;
class Node;
class NodePileup;
class Path;
class Pileup;
class Position;
class Snarl;
class SnarlTraversal;
class Subpath;
class Support;
class Translation;
class Visit;

enum SnarlType {
  UNCLASSIFIED = 0,
  ULTRABUBBLE = 1,
  SnarlType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SnarlType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SnarlType_IsValid(int value);
const SnarlType SnarlType_MIN = UNCLASSIFIED;
const SnarlType SnarlType_MAX = ULTRABUBBLE;
const int SnarlType_ARRAYSIZE = SnarlType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SnarlType_descriptor();
inline const ::std::string& SnarlType_Name(SnarlType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SnarlType_descriptor(), value);
}
inline bool SnarlType_Parse(
    const ::std::string& name, SnarlType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SnarlType>(
    SnarlType_descriptor(), name, value);
}
// ===================================================================

class Graph : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Graph) */ {
 public:
  Graph();
  virtual ~Graph();

  Graph(const Graph& from);

  inline Graph& operator=(const Graph& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Graph& default_instance();

  void Swap(Graph* other);

  // implements Message ----------------------------------------------

  inline Graph* New() const { return New(NULL); }

  Graph* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Graph& from);
  void MergeFrom(const Graph& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Graph* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vg.Node node = 1;
  int node_size() const;
  void clear_node();
  static const int kNodeFieldNumber = 1;
  const ::vg::Node& node(int index) const;
  ::vg::Node* mutable_node(int index);
  ::vg::Node* add_node();
  ::google::protobuf::RepeatedPtrField< ::vg::Node >*
      mutable_node();
  const ::google::protobuf::RepeatedPtrField< ::vg::Node >&
      node() const;

  // repeated .vg.Edge edge = 2;
  int edge_size() const;
  void clear_edge();
  static const int kEdgeFieldNumber = 2;
  const ::vg::Edge& edge(int index) const;
  ::vg::Edge* mutable_edge(int index);
  ::vg::Edge* add_edge();
  ::google::protobuf::RepeatedPtrField< ::vg::Edge >*
      mutable_edge();
  const ::google::protobuf::RepeatedPtrField< ::vg::Edge >&
      edge() const;

  // repeated .vg.Path path = 3;
  int path_size() const;
  void clear_path();
  static const int kPathFieldNumber = 3;
  const ::vg::Path& path(int index) const;
  ::vg::Path* mutable_path(int index);
  ::vg::Path* add_path();
  ::google::protobuf::RepeatedPtrField< ::vg::Path >*
      mutable_path();
  const ::google::protobuf::RepeatedPtrField< ::vg::Path >&
      path() const;

  // @@protoc_insertion_point(class_scope:vg.Graph)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::vg::Node > node_;
  ::google::protobuf::RepeatedPtrField< ::vg::Edge > edge_;
  ::google::protobuf::RepeatedPtrField< ::vg::Path > path_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static Graph* default_instance_;
};
// -------------------------------------------------------------------

class Node : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Node) */ {
 public:
  Node();
  virtual ~Node();

  Node(const Node& from);

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Node& default_instance();

  void Swap(Node* other);

  // implements Message ----------------------------------------------

  inline Node* New() const { return New(NULL); }

  Node* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Node* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string sequence = 1;
  void clear_sequence();
  static const int kSequenceFieldNumber = 1;
  const ::std::string& sequence() const;
  void set_sequence(const ::std::string& value);
  void set_sequence(const char* value);
  void set_sequence(const char* value, size_t size);
  ::std::string* mutable_sequence();
  ::std::string* release_sequence();
  void set_allocated_sequence(::std::string* sequence);

  // optional string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional int64 id = 3;
  void clear_id();
  static const int kIdFieldNumber = 3;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:vg.Node)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr sequence_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int64 id_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static Node* default_instance_;
};
// -------------------------------------------------------------------

class Edge : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Edge) */ {
 public:
  Edge();
  virtual ~Edge();

  Edge(const Edge& from);

  inline Edge& operator=(const Edge& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Edge& default_instance();

  void Swap(Edge* other);

  // implements Message ----------------------------------------------

  inline Edge* New() const { return New(NULL); }

  Edge* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Edge& from);
  void MergeFrom(const Edge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Edge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 from = 1;
  void clear_from();
  static const int kFromFieldNumber = 1;
  ::google::protobuf::int64 from() const;
  void set_from(::google::protobuf::int64 value);

  // optional int64 to = 2;
  void clear_to();
  static const int kToFieldNumber = 2;
  ::google::protobuf::int64 to() const;
  void set_to(::google::protobuf::int64 value);

  // optional bool from_start = 3;
  void clear_from_start();
  static const int kFromStartFieldNumber = 3;
  bool from_start() const;
  void set_from_start(bool value);

  // optional bool to_end = 4;
  void clear_to_end();
  static const int kToEndFieldNumber = 4;
  bool to_end() const;
  void set_to_end(bool value);

  // optional int32 overlap = 5;
  void clear_overlap();
  static const int kOverlapFieldNumber = 5;
  ::google::protobuf::int32 overlap() const;
  void set_overlap(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vg.Edge)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 from_;
  ::google::protobuf::int64 to_;
  bool from_start_;
  bool to_end_;
  ::google::protobuf::int32 overlap_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static Edge* default_instance_;
};
// -------------------------------------------------------------------

class Edit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Edit) */ {
 public:
  Edit();
  virtual ~Edit();

  Edit(const Edit& from);

  inline Edit& operator=(const Edit& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Edit& default_instance();

  void Swap(Edit* other);

  // implements Message ----------------------------------------------

  inline Edit* New() const { return New(NULL); }

  Edit* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Edit& from);
  void MergeFrom(const Edit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Edit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 from_length = 1;
  void clear_from_length();
  static const int kFromLengthFieldNumber = 1;
  ::google::protobuf::int32 from_length() const;
  void set_from_length(::google::protobuf::int32 value);

  // optional int32 to_length = 2;
  void clear_to_length();
  static const int kToLengthFieldNumber = 2;
  ::google::protobuf::int32 to_length() const;
  void set_to_length(::google::protobuf::int32 value);

  // optional string sequence = 3;
  void clear_sequence();
  static const int kSequenceFieldNumber = 3;
  const ::std::string& sequence() const;
  void set_sequence(const ::std::string& value);
  void set_sequence(const char* value);
  void set_sequence(const char* value, size_t size);
  ::std::string* mutable_sequence();
  ::std::string* release_sequence();
  void set_allocated_sequence(::std::string* sequence);

  // @@protoc_insertion_point(class_scope:vg.Edit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 from_length_;
  ::google::protobuf::int32 to_length_;
  ::google::protobuf::internal::ArenaStringPtr sequence_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static Edit* default_instance_;
};
// -------------------------------------------------------------------

class Mapping : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Mapping) */ {
 public:
  Mapping();
  virtual ~Mapping();

  Mapping(const Mapping& from);

  inline Mapping& operator=(const Mapping& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mapping& default_instance();

  void Swap(Mapping* other);

  // implements Message ----------------------------------------------

  inline Mapping* New() const { return New(NULL); }

  Mapping* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Mapping& from);
  void MergeFrom(const Mapping& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Mapping* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vg.Position position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  const ::vg::Position& position() const;
  ::vg::Position* mutable_position();
  ::vg::Position* release_position();
  void set_allocated_position(::vg::Position* position);

  // repeated .vg.Edit edit = 2;
  int edit_size() const;
  void clear_edit();
  static const int kEditFieldNumber = 2;
  const ::vg::Edit& edit(int index) const;
  ::vg::Edit* mutable_edit(int index);
  ::vg::Edit* add_edit();
  ::google::protobuf::RepeatedPtrField< ::vg::Edit >*
      mutable_edit();
  const ::google::protobuf::RepeatedPtrField< ::vg::Edit >&
      edit() const;

  // optional int64 rank = 5;
  void clear_rank();
  static const int kRankFieldNumber = 5;
  ::google::protobuf::int64 rank() const;
  void set_rank(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:vg.Mapping)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::vg::Position* position_;
  ::google::protobuf::RepeatedPtrField< ::vg::Edit > edit_;
  ::google::protobuf::int64 rank_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static Mapping* default_instance_;
};
// -------------------------------------------------------------------

class Position : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Position) */ {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Position& default_instance();

  void Swap(Position* other);

  // implements Message ----------------------------------------------

  inline Position* New() const { return New(NULL); }

  Position* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Position* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 node_id = 1;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  ::google::protobuf::int64 node_id() const;
  void set_node_id(::google::protobuf::int64 value);

  // optional int64 offset = 2;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  ::google::protobuf::int64 offset() const;
  void set_offset(::google::protobuf::int64 value);

  // optional bool is_reverse = 4;
  void clear_is_reverse();
  static const int kIsReverseFieldNumber = 4;
  bool is_reverse() const;
  void set_is_reverse(bool value);

  // optional string name = 5;
  void clear_name();
  static const int kNameFieldNumber = 5;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:vg.Position)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 node_id_;
  ::google::protobuf::int64 offset_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  bool is_reverse_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static Position* default_instance_;
};
// -------------------------------------------------------------------

class Path : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Path) */ {
 public:
  Path();
  virtual ~Path();

  Path(const Path& from);

  inline Path& operator=(const Path& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Path& default_instance();

  void Swap(Path* other);

  // implements Message ----------------------------------------------

  inline Path* New() const { return New(NULL); }

  Path* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Path& from);
  void MergeFrom(const Path& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Path* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .vg.Mapping mapping = 2;
  int mapping_size() const;
  void clear_mapping();
  static const int kMappingFieldNumber = 2;
  const ::vg::Mapping& mapping(int index) const;
  ::vg::Mapping* mutable_mapping(int index);
  ::vg::Mapping* add_mapping();
  ::google::protobuf::RepeatedPtrField< ::vg::Mapping >*
      mutable_mapping();
  const ::google::protobuf::RepeatedPtrField< ::vg::Mapping >&
      mapping() const;

  // optional bool is_circular = 3;
  void clear_is_circular();
  static const int kIsCircularFieldNumber = 3;
  bool is_circular() const;
  void set_is_circular(bool value);

  // optional int64 length = 4;
  void clear_length();
  static const int kLengthFieldNumber = 4;
  ::google::protobuf::int64 length() const;
  void set_length(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:vg.Path)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedPtrField< ::vg::Mapping > mapping_;
  ::google::protobuf::int64 length_;
  bool is_circular_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static Path* default_instance_;
};
// -------------------------------------------------------------------

class Alignment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Alignment) */ {
 public:
  Alignment();
  virtual ~Alignment();

  Alignment(const Alignment& from);

  inline Alignment& operator=(const Alignment& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Alignment& default_instance();

  void Swap(Alignment* other);

  // implements Message ----------------------------------------------

  inline Alignment* New() const { return New(NULL); }

  Alignment* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Alignment& from);
  void MergeFrom(const Alignment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Alignment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string sequence = 1;
  void clear_sequence();
  static const int kSequenceFieldNumber = 1;
  const ::std::string& sequence() const;
  void set_sequence(const ::std::string& value);
  void set_sequence(const char* value);
  void set_sequence(const char* value, size_t size);
  ::std::string* mutable_sequence();
  ::std::string* release_sequence();
  void set_allocated_sequence(::std::string* sequence);

  // optional .vg.Path path = 2;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::vg::Path& path() const;
  ::vg::Path* mutable_path();
  ::vg::Path* release_path();
  void set_allocated_path(::vg::Path* path);

  // optional string name = 3;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional bytes quality = 4;
  void clear_quality();
  static const int kQualityFieldNumber = 4;
  const ::std::string& quality() const;
  void set_quality(const ::std::string& value);
  void set_quality(const char* value);
  void set_quality(const void* value, size_t size);
  ::std::string* mutable_quality();
  ::std::string* release_quality();
  void set_allocated_quality(::std::string* quality);

  // optional int32 mapping_quality = 5;
  void clear_mapping_quality();
  static const int kMappingQualityFieldNumber = 5;
  ::google::protobuf::int32 mapping_quality() const;
  void set_mapping_quality(::google::protobuf::int32 value);

  // optional int32 score = 6;
  void clear_score();
  static const int kScoreFieldNumber = 6;
  ::google::protobuf::int32 score() const;
  void set_score(::google::protobuf::int32 value);

  // optional int32 query_position = 7;
  void clear_query_position();
  static const int kQueryPositionFieldNumber = 7;
  ::google::protobuf::int32 query_position() const;
  void set_query_position(::google::protobuf::int32 value);

  // optional string sample_name = 9;
  void clear_sample_name();
  static const int kSampleNameFieldNumber = 9;
  const ::std::string& sample_name() const;
  void set_sample_name(const ::std::string& value);
  void set_sample_name(const char* value);
  void set_sample_name(const char* value, size_t size);
  ::std::string* mutable_sample_name();
  ::std::string* release_sample_name();
  void set_allocated_sample_name(::std::string* sample_name);

  // optional string read_group = 10;
  void clear_read_group();
  static const int kReadGroupFieldNumber = 10;
  const ::std::string& read_group() const;
  void set_read_group(const ::std::string& value);
  void set_read_group(const char* value);
  void set_read_group(const char* value, size_t size);
  ::std::string* mutable_read_group();
  ::std::string* release_read_group();
  void set_allocated_read_group(::std::string* read_group);

  // optional .vg.Alignment fragment_prev = 11;
  bool has_fragment_prev() const;
  void clear_fragment_prev();
  static const int kFragmentPrevFieldNumber = 11;
  const ::vg::Alignment& fragment_prev() const;
  ::vg::Alignment* mutable_fragment_prev();
  ::vg::Alignment* release_fragment_prev();
  void set_allocated_fragment_prev(::vg::Alignment* fragment_prev);

  // optional .vg.Alignment fragment_next = 12;
  bool has_fragment_next() const;
  void clear_fragment_next();
  static const int kFragmentNextFieldNumber = 12;
  const ::vg::Alignment& fragment_next() const;
  ::vg::Alignment* mutable_fragment_next();
  ::vg::Alignment* release_fragment_next();
  void set_allocated_fragment_next(::vg::Alignment* fragment_next);

  // optional bool is_secondary = 15;
  void clear_is_secondary();
  static const int kIsSecondaryFieldNumber = 15;
  bool is_secondary() const;
  void set_is_secondary(bool value);

  // optional double identity = 16;
  void clear_identity();
  static const int kIdentityFieldNumber = 16;
  double identity() const;
  void set_identity(double value);

  // repeated .vg.Path fragment = 17;
  int fragment_size() const;
  void clear_fragment();
  static const int kFragmentFieldNumber = 17;
  const ::vg::Path& fragment(int index) const;
  ::vg::Path* mutable_fragment(int index);
  ::vg::Path* add_fragment();
  ::google::protobuf::RepeatedPtrField< ::vg::Path >*
      mutable_fragment();
  const ::google::protobuf::RepeatedPtrField< ::vg::Path >&
      fragment() const;

  // repeated .vg.Locus locus = 18;
  int locus_size() const;
  void clear_locus();
  static const int kLocusFieldNumber = 18;
  const ::vg::Locus& locus(int index) const;
  ::vg::Locus* mutable_locus(int index);
  ::vg::Locus* add_locus();
  ::google::protobuf::RepeatedPtrField< ::vg::Locus >*
      mutable_locus();
  const ::google::protobuf::RepeatedPtrField< ::vg::Locus >&
      locus() const;

  // repeated .vg.Position refpos = 19;
  int refpos_size() const;
  void clear_refpos();
  static const int kRefposFieldNumber = 19;
  const ::vg::Position& refpos(int index) const;
  ::vg::Position* mutable_refpos(int index);
  ::vg::Position* add_refpos();
  ::google::protobuf::RepeatedPtrField< ::vg::Position >*
      mutable_refpos();
  const ::google::protobuf::RepeatedPtrField< ::vg::Position >&
      refpos() const;

  // optional bool read_paired = 20;
  void clear_read_paired();
  static const int kReadPairedFieldNumber = 20;
  bool read_paired() const;
  void set_read_paired(bool value);

  // optional bool read_mapped = 21;
  void clear_read_mapped();
  static const int kReadMappedFieldNumber = 21;
  bool read_mapped() const;
  void set_read_mapped(bool value);

  // optional bool mate_unmapped = 22;
  void clear_mate_unmapped();
  static const int kMateUnmappedFieldNumber = 22;
  bool mate_unmapped() const;
  void set_mate_unmapped(bool value);

  // optional bool read_on_reverse_strand = 23;
  void clear_read_on_reverse_strand();
  static const int kReadOnReverseStrandFieldNumber = 23;
  bool read_on_reverse_strand() const;
  void set_read_on_reverse_strand(bool value);

  // optional bool mate_on_reverse_strand = 24;
  void clear_mate_on_reverse_strand();
  static const int kMateOnReverseStrandFieldNumber = 24;
  bool mate_on_reverse_strand() const;
  void set_mate_on_reverse_strand(bool value);

  // optional bool soft_clipped = 25;
  void clear_soft_clipped();
  static const int kSoftClippedFieldNumber = 25;
  bool soft_clipped() const;
  void set_soft_clipped(bool value);

  // optional bool discordant_insert_size = 26;
  void clear_discordant_insert_size();
  static const int kDiscordantInsertSizeFieldNumber = 26;
  bool discordant_insert_size() const;
  void set_discordant_insert_size(bool value);

  // optional double uniqueness = 27;
  void clear_uniqueness();
  static const int kUniquenessFieldNumber = 27;
  double uniqueness() const;
  void set_uniqueness(double value);

  // @@protoc_insertion_point(class_scope:vg.Alignment)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr sequence_;
  ::vg::Path* path_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr quality_;
  ::google::protobuf::int32 mapping_quality_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::internal::ArenaStringPtr sample_name_;
  ::google::protobuf::internal::ArenaStringPtr read_group_;
  ::vg::Alignment* fragment_prev_;
  ::vg::Alignment* fragment_next_;
  double identity_;
  ::google::protobuf::RepeatedPtrField< ::vg::Path > fragment_;
  ::google::protobuf::int32 query_position_;
  bool is_secondary_;
  bool read_paired_;
  bool read_mapped_;
  bool mate_unmapped_;
  ::google::protobuf::RepeatedPtrField< ::vg::Locus > locus_;
  ::google::protobuf::RepeatedPtrField< ::vg::Position > refpos_;
  double uniqueness_;
  bool read_on_reverse_strand_;
  bool mate_on_reverse_strand_;
  bool soft_clipped_;
  bool discordant_insert_size_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static Alignment* default_instance_;
};
// -------------------------------------------------------------------

class MultipathAlignment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.MultipathAlignment) */ {
 public:
  MultipathAlignment();
  virtual ~MultipathAlignment();

  MultipathAlignment(const MultipathAlignment& from);

  inline MultipathAlignment& operator=(const MultipathAlignment& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultipathAlignment& default_instance();

  void Swap(MultipathAlignment* other);

  // implements Message ----------------------------------------------

  inline MultipathAlignment* New() const { return New(NULL); }

  MultipathAlignment* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MultipathAlignment& from);
  void MergeFrom(const MultipathAlignment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MultipathAlignment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string sequence = 1;
  void clear_sequence();
  static const int kSequenceFieldNumber = 1;
  const ::std::string& sequence() const;
  void set_sequence(const ::std::string& value);
  void set_sequence(const char* value);
  void set_sequence(const char* value, size_t size);
  ::std::string* mutable_sequence();
  ::std::string* release_sequence();
  void set_allocated_sequence(::std::string* sequence);

  // optional bytes quality = 2;
  void clear_quality();
  static const int kQualityFieldNumber = 2;
  const ::std::string& quality() const;
  void set_quality(const ::std::string& value);
  void set_quality(const char* value);
  void set_quality(const void* value, size_t size);
  ::std::string* mutable_quality();
  ::std::string* release_quality();
  void set_allocated_quality(::std::string* quality);

  // optional string name = 3;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string sample_name = 4;
  void clear_sample_name();
  static const int kSampleNameFieldNumber = 4;
  const ::std::string& sample_name() const;
  void set_sample_name(const ::std::string& value);
  void set_sample_name(const char* value);
  void set_sample_name(const char* value, size_t size);
  ::std::string* mutable_sample_name();
  ::std::string* release_sample_name();
  void set_allocated_sample_name(::std::string* sample_name);

  // optional string read_group = 5;
  void clear_read_group();
  static const int kReadGroupFieldNumber = 5;
  const ::std::string& read_group() const;
  void set_read_group(const ::std::string& value);
  void set_read_group(const char* value);
  void set_read_group(const char* value, size_t size);
  ::std::string* mutable_read_group();
  ::std::string* release_read_group();
  void set_allocated_read_group(::std::string* read_group);

  // repeated .vg.Subpath subpath = 6;
  int subpath_size() const;
  void clear_subpath();
  static const int kSubpathFieldNumber = 6;
  const ::vg::Subpath& subpath(int index) const;
  ::vg::Subpath* mutable_subpath(int index);
  ::vg::Subpath* add_subpath();
  ::google::protobuf::RepeatedPtrField< ::vg::Subpath >*
      mutable_subpath();
  const ::google::protobuf::RepeatedPtrField< ::vg::Subpath >&
      subpath() const;

  // optional int32 mapping_quality = 7;
  void clear_mapping_quality();
  static const int kMappingQualityFieldNumber = 7;
  ::google::protobuf::int32 mapping_quality() const;
  void set_mapping_quality(::google::protobuf::int32 value);

  // repeated uint32 start = 8;
  int start_size() const;
  void clear_start();
  static const int kStartFieldNumber = 8;
  ::google::protobuf::uint32 start(int index) const;
  void set_start(int index, ::google::protobuf::uint32 value);
  void add_start(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      start() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_start();

  // @@protoc_insertion_point(class_scope:vg.MultipathAlignment)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr sequence_;
  ::google::protobuf::internal::ArenaStringPtr quality_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr sample_name_;
  ::google::protobuf::internal::ArenaStringPtr read_group_;
  ::google::protobuf::RepeatedPtrField< ::vg::Subpath > subpath_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > start_;
  mutable int _start_cached_byte_size_;
  ::google::protobuf::int32 mapping_quality_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static MultipathAlignment* default_instance_;
};
// -------------------------------------------------------------------

class Subpath : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Subpath) */ {
 public:
  Subpath();
  virtual ~Subpath();

  Subpath(const Subpath& from);

  inline Subpath& operator=(const Subpath& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Subpath& default_instance();

  void Swap(Subpath* other);

  // implements Message ----------------------------------------------

  inline Subpath* New() const { return New(NULL); }

  Subpath* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Subpath& from);
  void MergeFrom(const Subpath& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Subpath* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vg.Path path = 1;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::vg::Path& path() const;
  ::vg::Path* mutable_path();
  ::vg::Path* release_path();
  void set_allocated_path(::vg::Path* path);

  // repeated uint32 next = 2;
  int next_size() const;
  void clear_next();
  static const int kNextFieldNumber = 2;
  ::google::protobuf::uint32 next(int index) const;
  void set_next(int index, ::google::protobuf::uint32 value);
  void add_next(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      next() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_next();

  // optional int32 score = 3;
  void clear_score();
  static const int kScoreFieldNumber = 3;
  ::google::protobuf::int32 score() const;
  void set_score(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vg.Subpath)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::vg::Path* path_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > next_;
  mutable int _next_cached_byte_size_;
  ::google::protobuf::int32 score_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static Subpath* default_instance_;
};
// -------------------------------------------------------------------

class KmerMatch : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.KmerMatch) */ {
 public:
  KmerMatch();
  virtual ~KmerMatch();

  KmerMatch(const KmerMatch& from);

  inline KmerMatch& operator=(const KmerMatch& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KmerMatch& default_instance();

  void Swap(KmerMatch* other);

  // implements Message ----------------------------------------------

  inline KmerMatch* New() const { return New(NULL); }

  KmerMatch* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KmerMatch& from);
  void MergeFrom(const KmerMatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KmerMatch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string sequence = 1;
  void clear_sequence();
  static const int kSequenceFieldNumber = 1;
  const ::std::string& sequence() const;
  void set_sequence(const ::std::string& value);
  void set_sequence(const char* value);
  void set_sequence(const char* value, size_t size);
  ::std::string* mutable_sequence();
  ::std::string* release_sequence();
  void set_allocated_sequence(::std::string* sequence);

  // optional int64 node_id = 2;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 2;
  ::google::protobuf::int64 node_id() const;
  void set_node_id(::google::protobuf::int64 value);

  // optional sint32 position = 3;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  ::google::protobuf::int32 position() const;
  void set_position(::google::protobuf::int32 value);

  // optional bool backward = 4;
  void clear_backward();
  static const int kBackwardFieldNumber = 4;
  bool backward() const;
  void set_backward(bool value);

  // @@protoc_insertion_point(class_scope:vg.KmerMatch)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr sequence_;
  ::google::protobuf::int64 node_id_;
  ::google::protobuf::int32 position_;
  bool backward_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static KmerMatch* default_instance_;
};
// -------------------------------------------------------------------

class BasePileup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.BasePileup) */ {
 public:
  BasePileup();
  virtual ~BasePileup();

  BasePileup(const BasePileup& from);

  inline BasePileup& operator=(const BasePileup& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BasePileup& default_instance();

  void Swap(BasePileup* other);

  // implements Message ----------------------------------------------

  inline BasePileup* New() const { return New(NULL); }

  BasePileup* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BasePileup& from);
  void MergeFrom(const BasePileup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BasePileup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ref_base = 1;
  void clear_ref_base();
  static const int kRefBaseFieldNumber = 1;
  ::google::protobuf::int32 ref_base() const;
  void set_ref_base(::google::protobuf::int32 value);

  // optional int32 num_bases = 2;
  void clear_num_bases();
  static const int kNumBasesFieldNumber = 2;
  ::google::protobuf::int32 num_bases() const;
  void set_num_bases(::google::protobuf::int32 value);

  // optional string bases = 3;
  void clear_bases();
  static const int kBasesFieldNumber = 3;
  const ::std::string& bases() const;
  void set_bases(const ::std::string& value);
  void set_bases(const char* value);
  void set_bases(const char* value, size_t size);
  ::std::string* mutable_bases();
  ::std::string* release_bases();
  void set_allocated_bases(::std::string* bases);

  // optional bytes qualities = 4;
  void clear_qualities();
  static const int kQualitiesFieldNumber = 4;
  const ::std::string& qualities() const;
  void set_qualities(const ::std::string& value);
  void set_qualities(const char* value);
  void set_qualities(const void* value, size_t size);
  ::std::string* mutable_qualities();
  ::std::string* release_qualities();
  void set_allocated_qualities(::std::string* qualities);

  // @@protoc_insertion_point(class_scope:vg.BasePileup)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 ref_base_;
  ::google::protobuf::int32 num_bases_;
  ::google::protobuf::internal::ArenaStringPtr bases_;
  ::google::protobuf::internal::ArenaStringPtr qualities_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static BasePileup* default_instance_;
};
// -------------------------------------------------------------------

class NodePileup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.NodePileup) */ {
 public:
  NodePileup();
  virtual ~NodePileup();

  NodePileup(const NodePileup& from);

  inline NodePileup& operator=(const NodePileup& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodePileup& default_instance();

  void Swap(NodePileup* other);

  // implements Message ----------------------------------------------

  inline NodePileup* New() const { return New(NULL); }

  NodePileup* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodePileup& from);
  void MergeFrom(const NodePileup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NodePileup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 node_id = 1;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  ::google::protobuf::int64 node_id() const;
  void set_node_id(::google::protobuf::int64 value);

  // repeated .vg.BasePileup base_pileup = 2;
  int base_pileup_size() const;
  void clear_base_pileup();
  static const int kBasePileupFieldNumber = 2;
  const ::vg::BasePileup& base_pileup(int index) const;
  ::vg::BasePileup* mutable_base_pileup(int index);
  ::vg::BasePileup* add_base_pileup();
  ::google::protobuf::RepeatedPtrField< ::vg::BasePileup >*
      mutable_base_pileup();
  const ::google::protobuf::RepeatedPtrField< ::vg::BasePileup >&
      base_pileup() const;

  // @@protoc_insertion_point(class_scope:vg.NodePileup)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 node_id_;
  ::google::protobuf::RepeatedPtrField< ::vg::BasePileup > base_pileup_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static NodePileup* default_instance_;
};
// -------------------------------------------------------------------

class EdgePileup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.EdgePileup) */ {
 public:
  EdgePileup();
  virtual ~EdgePileup();

  EdgePileup(const EdgePileup& from);

  inline EdgePileup& operator=(const EdgePileup& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EdgePileup& default_instance();

  void Swap(EdgePileup* other);

  // implements Message ----------------------------------------------

  inline EdgePileup* New() const { return New(NULL); }

  EdgePileup* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EdgePileup& from);
  void MergeFrom(const EdgePileup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EdgePileup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vg.Edge edge = 1;
  bool has_edge() const;
  void clear_edge();
  static const int kEdgeFieldNumber = 1;
  const ::vg::Edge& edge() const;
  ::vg::Edge* mutable_edge();
  ::vg::Edge* release_edge();
  void set_allocated_edge(::vg::Edge* edge);

  // optional int32 num_reads = 2;
  void clear_num_reads();
  static const int kNumReadsFieldNumber = 2;
  ::google::protobuf::int32 num_reads() const;
  void set_num_reads(::google::protobuf::int32 value);

  // optional int32 num_forward_reads = 3;
  void clear_num_forward_reads();
  static const int kNumForwardReadsFieldNumber = 3;
  ::google::protobuf::int32 num_forward_reads() const;
  void set_num_forward_reads(::google::protobuf::int32 value);

  // optional bytes qualities = 4;
  void clear_qualities();
  static const int kQualitiesFieldNumber = 4;
  const ::std::string& qualities() const;
  void set_qualities(const ::std::string& value);
  void set_qualities(const char* value);
  void set_qualities(const void* value, size_t size);
  ::std::string* mutable_qualities();
  ::std::string* release_qualities();
  void set_allocated_qualities(::std::string* qualities);

  // @@protoc_insertion_point(class_scope:vg.EdgePileup)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::vg::Edge* edge_;
  ::google::protobuf::int32 num_reads_;
  ::google::protobuf::int32 num_forward_reads_;
  ::google::protobuf::internal::ArenaStringPtr qualities_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static EdgePileup* default_instance_;
};
// -------------------------------------------------------------------

class Pileup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Pileup) */ {
 public:
  Pileup();
  virtual ~Pileup();

  Pileup(const Pileup& from);

  inline Pileup& operator=(const Pileup& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pileup& default_instance();

  void Swap(Pileup* other);

  // implements Message ----------------------------------------------

  inline Pileup* New() const { return New(NULL); }

  Pileup* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pileup& from);
  void MergeFrom(const Pileup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Pileup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vg.NodePileup node_pileups = 1;
  int node_pileups_size() const;
  void clear_node_pileups();
  static const int kNodePileupsFieldNumber = 1;
  const ::vg::NodePileup& node_pileups(int index) const;
  ::vg::NodePileup* mutable_node_pileups(int index);
  ::vg::NodePileup* add_node_pileups();
  ::google::protobuf::RepeatedPtrField< ::vg::NodePileup >*
      mutable_node_pileups();
  const ::google::protobuf::RepeatedPtrField< ::vg::NodePileup >&
      node_pileups() const;

  // repeated .vg.EdgePileup edge_pileups = 2;
  int edge_pileups_size() const;
  void clear_edge_pileups();
  static const int kEdgePileupsFieldNumber = 2;
  const ::vg::EdgePileup& edge_pileups(int index) const;
  ::vg::EdgePileup* mutable_edge_pileups(int index);
  ::vg::EdgePileup* add_edge_pileups();
  ::google::protobuf::RepeatedPtrField< ::vg::EdgePileup >*
      mutable_edge_pileups();
  const ::google::protobuf::RepeatedPtrField< ::vg::EdgePileup >&
      edge_pileups() const;

  // @@protoc_insertion_point(class_scope:vg.Pileup)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::vg::NodePileup > node_pileups_;
  ::google::protobuf::RepeatedPtrField< ::vg::EdgePileup > edge_pileups_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static Pileup* default_instance_;
};
// -------------------------------------------------------------------

class Snarl : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Snarl) */ {
 public:
  Snarl();
  virtual ~Snarl();

  Snarl(const Snarl& from);

  inline Snarl& operator=(const Snarl& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Snarl& default_instance();

  void Swap(Snarl* other);

  // implements Message ----------------------------------------------

  inline Snarl* New() const { return New(NULL); }

  Snarl* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Snarl& from);
  void MergeFrom(const Snarl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Snarl* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vg.SnarlType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::vg::SnarlType type() const;
  void set_type(::vg::SnarlType value);

  // optional .vg.Visit start = 2;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 2;
  const ::vg::Visit& start() const;
  ::vg::Visit* mutable_start();
  ::vg::Visit* release_start();
  void set_allocated_start(::vg::Visit* start);

  // optional .vg.Visit end = 3;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 3;
  const ::vg::Visit& end() const;
  ::vg::Visit* mutable_end();
  ::vg::Visit* release_end();
  void set_allocated_end(::vg::Visit* end);

  // optional .vg.Snarl parent = 4;
  bool has_parent() const;
  void clear_parent();
  static const int kParentFieldNumber = 4;
  const ::vg::Snarl& parent() const;
  ::vg::Snarl* mutable_parent();
  ::vg::Snarl* release_parent();
  void set_allocated_parent(::vg::Snarl* parent);

  // optional string name = 5;
  void clear_name();
  static const int kNameFieldNumber = 5;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:vg.Snarl)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::vg::Visit* start_;
  ::vg::Visit* end_;
  ::vg::Snarl* parent_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static Snarl* default_instance_;
};
// -------------------------------------------------------------------

class Visit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Visit) */ {
 public:
  Visit();
  virtual ~Visit();

  Visit(const Visit& from);

  inline Visit& operator=(const Visit& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Visit& default_instance();

  void Swap(Visit* other);

  // implements Message ----------------------------------------------

  inline Visit* New() const { return New(NULL); }

  Visit* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Visit& from);
  void MergeFrom(const Visit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Visit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 node_id = 1;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  ::google::protobuf::int64 node_id() const;
  void set_node_id(::google::protobuf::int64 value);

  // optional .vg.Snarl snarl = 2;
  bool has_snarl() const;
  void clear_snarl();
  static const int kSnarlFieldNumber = 2;
  const ::vg::Snarl& snarl() const;
  ::vg::Snarl* mutable_snarl();
  ::vg::Snarl* release_snarl();
  void set_allocated_snarl(::vg::Snarl* snarl);

  // optional bool backward = 3;
  void clear_backward();
  static const int kBackwardFieldNumber = 3;
  bool backward() const;
  void set_backward(bool value);

  // @@protoc_insertion_point(class_scope:vg.Visit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 node_id_;
  ::vg::Snarl* snarl_;
  bool backward_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static Visit* default_instance_;
};
// -------------------------------------------------------------------

class SnarlTraversal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.SnarlTraversal) */ {
 public:
  SnarlTraversal();
  virtual ~SnarlTraversal();

  SnarlTraversal(const SnarlTraversal& from);

  inline SnarlTraversal& operator=(const SnarlTraversal& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SnarlTraversal& default_instance();

  void Swap(SnarlTraversal* other);

  // implements Message ----------------------------------------------

  inline SnarlTraversal* New() const { return New(NULL); }

  SnarlTraversal* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SnarlTraversal& from);
  void MergeFrom(const SnarlTraversal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SnarlTraversal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vg.Visit visits = 1;
  int visits_size() const;
  void clear_visits();
  static const int kVisitsFieldNumber = 1;
  const ::vg::Visit& visits(int index) const;
  ::vg::Visit* mutable_visits(int index);
  ::vg::Visit* add_visits();
  ::google::protobuf::RepeatedPtrField< ::vg::Visit >*
      mutable_visits();
  const ::google::protobuf::RepeatedPtrField< ::vg::Visit >&
      visits() const;

  // optional .vg.Snarl snarl = 2;
  bool has_snarl() const;
  void clear_snarl();
  static const int kSnarlFieldNumber = 2;
  const ::vg::Snarl& snarl() const;
  ::vg::Snarl* mutable_snarl();
  ::vg::Snarl* release_snarl();
  void set_allocated_snarl(::vg::Snarl* snarl);

  // optional string name = 3;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:vg.SnarlTraversal)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::vg::Visit > visits_;
  ::vg::Snarl* snarl_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static SnarlTraversal* default_instance_;
};
// -------------------------------------------------------------------

class Locus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Locus) */ {
 public:
  Locus();
  virtual ~Locus();

  Locus(const Locus& from);

  inline Locus& operator=(const Locus& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Locus& default_instance();

  void Swap(Locus* other);

  // implements Message ----------------------------------------------

  inline Locus* New() const { return New(NULL); }

  Locus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Locus& from);
  void MergeFrom(const Locus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Locus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .vg.Path allele = 2;
  int allele_size() const;
  void clear_allele();
  static const int kAlleleFieldNumber = 2;
  const ::vg::Path& allele(int index) const;
  ::vg::Path* mutable_allele(int index);
  ::vg::Path* add_allele();
  ::google::protobuf::RepeatedPtrField< ::vg::Path >*
      mutable_allele();
  const ::google::protobuf::RepeatedPtrField< ::vg::Path >&
      allele() const;

  // repeated .vg.Support support = 3;
  int support_size() const;
  void clear_support();
  static const int kSupportFieldNumber = 3;
  const ::vg::Support& support(int index) const;
  ::vg::Support* mutable_support(int index);
  ::vg::Support* add_support();
  ::google::protobuf::RepeatedPtrField< ::vg::Support >*
      mutable_support();
  const ::google::protobuf::RepeatedPtrField< ::vg::Support >&
      support() const;

  // repeated .vg.Genotype genotype = 4;
  int genotype_size() const;
  void clear_genotype();
  static const int kGenotypeFieldNumber = 4;
  const ::vg::Genotype& genotype(int index) const;
  ::vg::Genotype* mutable_genotype(int index);
  ::vg::Genotype* add_genotype();
  ::google::protobuf::RepeatedPtrField< ::vg::Genotype >*
      mutable_genotype();
  const ::google::protobuf::RepeatedPtrField< ::vg::Genotype >&
      genotype() const;

  // optional .vg.Support overall_support = 5;
  bool has_overall_support() const;
  void clear_overall_support();
  static const int kOverallSupportFieldNumber = 5;
  const ::vg::Support& overall_support() const;
  ::vg::Support* mutable_overall_support();
  ::vg::Support* release_overall_support();
  void set_allocated_overall_support(::vg::Support* overall_support);

  // repeated double allele_log_likelihood = 6;
  int allele_log_likelihood_size() const;
  void clear_allele_log_likelihood();
  static const int kAlleleLogLikelihoodFieldNumber = 6;
  double allele_log_likelihood(int index) const;
  void set_allele_log_likelihood(int index, double value);
  void add_allele_log_likelihood(double value);
  const ::google::protobuf::RepeatedField< double >&
      allele_log_likelihood() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_allele_log_likelihood();

  // @@protoc_insertion_point(class_scope:vg.Locus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedPtrField< ::vg::Path > allele_;
  ::google::protobuf::RepeatedPtrField< ::vg::Support > support_;
  ::google::protobuf::RepeatedPtrField< ::vg::Genotype > genotype_;
  ::vg::Support* overall_support_;
  ::google::protobuf::RepeatedField< double > allele_log_likelihood_;
  mutable int _allele_log_likelihood_cached_byte_size_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static Locus* default_instance_;
};
// -------------------------------------------------------------------

class Genotype : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Genotype) */ {
 public:
  Genotype();
  virtual ~Genotype();

  Genotype(const Genotype& from);

  inline Genotype& operator=(const Genotype& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Genotype& default_instance();

  void Swap(Genotype* other);

  // implements Message ----------------------------------------------

  inline Genotype* New() const { return New(NULL); }

  Genotype* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Genotype& from);
  void MergeFrom(const Genotype& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Genotype* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 allele = 1;
  int allele_size() const;
  void clear_allele();
  static const int kAlleleFieldNumber = 1;
  ::google::protobuf::int32 allele(int index) const;
  void set_allele(int index, ::google::protobuf::int32 value);
  void add_allele(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      allele() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_allele();

  // optional bool is_phased = 2;
  void clear_is_phased();
  static const int kIsPhasedFieldNumber = 2;
  bool is_phased() const;
  void set_is_phased(bool value);

  // optional double likelihood = 3;
  void clear_likelihood();
  static const int kLikelihoodFieldNumber = 3;
  double likelihood() const;
  void set_likelihood(double value);

  // optional double log_likelihood = 4;
  void clear_log_likelihood();
  static const int kLogLikelihoodFieldNumber = 4;
  double log_likelihood() const;
  void set_log_likelihood(double value);

  // optional double log_prior = 5;
  void clear_log_prior();
  static const int kLogPriorFieldNumber = 5;
  double log_prior() const;
  void set_log_prior(double value);

  // optional double log_posterior = 6;
  void clear_log_posterior();
  static const int kLogPosteriorFieldNumber = 6;
  double log_posterior() const;
  void set_log_posterior(double value);

  // @@protoc_insertion_point(class_scope:vg.Genotype)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > allele_;
  mutable int _allele_cached_byte_size_;
  double likelihood_;
  double log_likelihood_;
  double log_prior_;
  double log_posterior_;
  bool is_phased_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static Genotype* default_instance_;
};
// -------------------------------------------------------------------

class Support : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Support) */ {
 public:
  Support();
  virtual ~Support();

  Support(const Support& from);

  inline Support& operator=(const Support& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Support& default_instance();

  void Swap(Support* other);

  // implements Message ----------------------------------------------

  inline Support* New() const { return New(NULL); }

  Support* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Support& from);
  void MergeFrom(const Support& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Support* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double quality = 1;
  void clear_quality();
  static const int kQualityFieldNumber = 1;
  double quality() const;
  void set_quality(double value);

  // optional double forward = 2;
  void clear_forward();
  static const int kForwardFieldNumber = 2;
  double forward() const;
  void set_forward(double value);

  // optional double reverse = 3;
  void clear_reverse();
  static const int kReverseFieldNumber = 3;
  double reverse() const;
  void set_reverse(double value);

  // optional double left = 4;
  void clear_left();
  static const int kLeftFieldNumber = 4;
  double left() const;
  void set_left(double value);

  // optional double right = 5;
  void clear_right();
  static const int kRightFieldNumber = 5;
  double right() const;
  void set_right(double value);

  // @@protoc_insertion_point(class_scope:vg.Support)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  double quality_;
  double forward_;
  double reverse_;
  double left_;
  double right_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static Support* default_instance_;
};
// -------------------------------------------------------------------

class Translation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vg.Translation) */ {
 public:
  Translation();
  virtual ~Translation();

  Translation(const Translation& from);

  inline Translation& operator=(const Translation& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Translation& default_instance();

  void Swap(Translation* other);

  // implements Message ----------------------------------------------

  inline Translation* New() const { return New(NULL); }

  Translation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Translation& from);
  void MergeFrom(const Translation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Translation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vg.Path from = 1;
  bool has_from() const;
  void clear_from();
  static const int kFromFieldNumber = 1;
  const ::vg::Path& from() const;
  ::vg::Path* mutable_from();
  ::vg::Path* release_from();
  void set_allocated_from(::vg::Path* from);

  // optional .vg.Path to = 2;
  bool has_to() const;
  void clear_to();
  static const int kToFieldNumber = 2;
  const ::vg::Path& to() const;
  ::vg::Path* mutable_to();
  ::vg::Path* release_to();
  void set_allocated_to(::vg::Path* to);

  // @@protoc_insertion_point(class_scope:vg.Translation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::vg::Path* from_;
  ::vg::Path* to_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vg_2eproto();
  friend void protobuf_AssignDesc_vg_2eproto();
  friend void protobuf_ShutdownFile_vg_2eproto();

  void InitAsDefaultInstance();
  static Translation* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Graph

// repeated .vg.Node node = 1;
inline int Graph::node_size() const {
  return node_.size();
}
inline void Graph::clear_node() {
  node_.Clear();
}
inline const ::vg::Node& Graph::node(int index) const {
  // @@protoc_insertion_point(field_get:vg.Graph.node)
  return node_.Get(index);
}
inline ::vg::Node* Graph::mutable_node(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Graph.node)
  return node_.Mutable(index);
}
inline ::vg::Node* Graph::add_node() {
  // @@protoc_insertion_point(field_add:vg.Graph.node)
  return node_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Node >*
Graph::mutable_node() {
  // @@protoc_insertion_point(field_mutable_list:vg.Graph.node)
  return &node_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Node >&
Graph::node() const {
  // @@protoc_insertion_point(field_list:vg.Graph.node)
  return node_;
}

// repeated .vg.Edge edge = 2;
inline int Graph::edge_size() const {
  return edge_.size();
}
inline void Graph::clear_edge() {
  edge_.Clear();
}
inline const ::vg::Edge& Graph::edge(int index) const {
  // @@protoc_insertion_point(field_get:vg.Graph.edge)
  return edge_.Get(index);
}
inline ::vg::Edge* Graph::mutable_edge(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Graph.edge)
  return edge_.Mutable(index);
}
inline ::vg::Edge* Graph::add_edge() {
  // @@protoc_insertion_point(field_add:vg.Graph.edge)
  return edge_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Edge >*
Graph::mutable_edge() {
  // @@protoc_insertion_point(field_mutable_list:vg.Graph.edge)
  return &edge_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Edge >&
Graph::edge() const {
  // @@protoc_insertion_point(field_list:vg.Graph.edge)
  return edge_;
}

// repeated .vg.Path path = 3;
inline int Graph::path_size() const {
  return path_.size();
}
inline void Graph::clear_path() {
  path_.Clear();
}
inline const ::vg::Path& Graph::path(int index) const {
  // @@protoc_insertion_point(field_get:vg.Graph.path)
  return path_.Get(index);
}
inline ::vg::Path* Graph::mutable_path(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Graph.path)
  return path_.Mutable(index);
}
inline ::vg::Path* Graph::add_path() {
  // @@protoc_insertion_point(field_add:vg.Graph.path)
  return path_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Path >*
Graph::mutable_path() {
  // @@protoc_insertion_point(field_mutable_list:vg.Graph.path)
  return &path_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Path >&
Graph::path() const {
  // @@protoc_insertion_point(field_list:vg.Graph.path)
  return path_;
}

// -------------------------------------------------------------------

// Node

// optional string sequence = 1;
inline void Node::clear_sequence() {
  sequence_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Node::sequence() const {
  // @@protoc_insertion_point(field_get:vg.Node.sequence)
  return sequence_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_sequence(const ::std::string& value) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Node.sequence)
}
inline void Node::set_sequence(const char* value) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Node.sequence)
}
inline void Node::set_sequence(const char* value, size_t size) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Node.sequence)
}
inline ::std::string* Node::mutable_sequence() {
  
  // @@protoc_insertion_point(field_mutable:vg.Node.sequence)
  return sequence_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_sequence() {
  // @@protoc_insertion_point(field_release:vg.Node.sequence)
  
  return sequence_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_sequence(::std::string* sequence) {
  if (sequence != NULL) {
    
  } else {
    
  }
  sequence_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sequence);
  // @@protoc_insertion_point(field_set_allocated:vg.Node.sequence)
}

// optional string name = 2;
inline void Node::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Node::name() const {
  // @@protoc_insertion_point(field_get:vg.Node.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Node.name)
}
inline void Node::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Node.name)
}
inline void Node::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Node.name)
}
inline ::std::string* Node::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:vg.Node.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_name() {
  // @@protoc_insertion_point(field_release:vg.Node.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vg.Node.name)
}

// optional int64 id = 3;
inline void Node::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Node::id() const {
  // @@protoc_insertion_point(field_get:vg.Node.id)
  return id_;
}
inline void Node::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:vg.Node.id)
}

// -------------------------------------------------------------------

// Edge

// optional int64 from = 1;
inline void Edge::clear_from() {
  from_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Edge::from() const {
  // @@protoc_insertion_point(field_get:vg.Edge.from)
  return from_;
}
inline void Edge::set_from(::google::protobuf::int64 value) {
  
  from_ = value;
  // @@protoc_insertion_point(field_set:vg.Edge.from)
}

// optional int64 to = 2;
inline void Edge::clear_to() {
  to_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Edge::to() const {
  // @@protoc_insertion_point(field_get:vg.Edge.to)
  return to_;
}
inline void Edge::set_to(::google::protobuf::int64 value) {
  
  to_ = value;
  // @@protoc_insertion_point(field_set:vg.Edge.to)
}

// optional bool from_start = 3;
inline void Edge::clear_from_start() {
  from_start_ = false;
}
inline bool Edge::from_start() const {
  // @@protoc_insertion_point(field_get:vg.Edge.from_start)
  return from_start_;
}
inline void Edge::set_from_start(bool value) {
  
  from_start_ = value;
  // @@protoc_insertion_point(field_set:vg.Edge.from_start)
}

// optional bool to_end = 4;
inline void Edge::clear_to_end() {
  to_end_ = false;
}
inline bool Edge::to_end() const {
  // @@protoc_insertion_point(field_get:vg.Edge.to_end)
  return to_end_;
}
inline void Edge::set_to_end(bool value) {
  
  to_end_ = value;
  // @@protoc_insertion_point(field_set:vg.Edge.to_end)
}

// optional int32 overlap = 5;
inline void Edge::clear_overlap() {
  overlap_ = 0;
}
inline ::google::protobuf::int32 Edge::overlap() const {
  // @@protoc_insertion_point(field_get:vg.Edge.overlap)
  return overlap_;
}
inline void Edge::set_overlap(::google::protobuf::int32 value) {
  
  overlap_ = value;
  // @@protoc_insertion_point(field_set:vg.Edge.overlap)
}

// -------------------------------------------------------------------

// Edit

// optional int32 from_length = 1;
inline void Edit::clear_from_length() {
  from_length_ = 0;
}
inline ::google::protobuf::int32 Edit::from_length() const {
  // @@protoc_insertion_point(field_get:vg.Edit.from_length)
  return from_length_;
}
inline void Edit::set_from_length(::google::protobuf::int32 value) {
  
  from_length_ = value;
  // @@protoc_insertion_point(field_set:vg.Edit.from_length)
}

// optional int32 to_length = 2;
inline void Edit::clear_to_length() {
  to_length_ = 0;
}
inline ::google::protobuf::int32 Edit::to_length() const {
  // @@protoc_insertion_point(field_get:vg.Edit.to_length)
  return to_length_;
}
inline void Edit::set_to_length(::google::protobuf::int32 value) {
  
  to_length_ = value;
  // @@protoc_insertion_point(field_set:vg.Edit.to_length)
}

// optional string sequence = 3;
inline void Edit::clear_sequence() {
  sequence_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Edit::sequence() const {
  // @@protoc_insertion_point(field_get:vg.Edit.sequence)
  return sequence_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Edit::set_sequence(const ::std::string& value) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Edit.sequence)
}
inline void Edit::set_sequence(const char* value) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Edit.sequence)
}
inline void Edit::set_sequence(const char* value, size_t size) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Edit.sequence)
}
inline ::std::string* Edit::mutable_sequence() {
  
  // @@protoc_insertion_point(field_mutable:vg.Edit.sequence)
  return sequence_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Edit::release_sequence() {
  // @@protoc_insertion_point(field_release:vg.Edit.sequence)
  
  return sequence_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Edit::set_allocated_sequence(::std::string* sequence) {
  if (sequence != NULL) {
    
  } else {
    
  }
  sequence_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sequence);
  // @@protoc_insertion_point(field_set_allocated:vg.Edit.sequence)
}

// -------------------------------------------------------------------

// Mapping

// optional .vg.Position position = 1;
inline bool Mapping::has_position() const {
  return !_is_default_instance_ && position_ != NULL;
}
inline void Mapping::clear_position() {
  if (GetArenaNoVirtual() == NULL && position_ != NULL) delete position_;
  position_ = NULL;
}
inline const ::vg::Position& Mapping::position() const {
  // @@protoc_insertion_point(field_get:vg.Mapping.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::vg::Position* Mapping::mutable_position() {
  
  if (position_ == NULL) {
    position_ = new ::vg::Position;
  }
  // @@protoc_insertion_point(field_mutable:vg.Mapping.position)
  return position_;
}
inline ::vg::Position* Mapping::release_position() {
  // @@protoc_insertion_point(field_release:vg.Mapping.position)
  
  ::vg::Position* temp = position_;
  position_ = NULL;
  return temp;
}
inline void Mapping::set_allocated_position(::vg::Position* position) {
  delete position_;
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:vg.Mapping.position)
}

// repeated .vg.Edit edit = 2;
inline int Mapping::edit_size() const {
  return edit_.size();
}
inline void Mapping::clear_edit() {
  edit_.Clear();
}
inline const ::vg::Edit& Mapping::edit(int index) const {
  // @@protoc_insertion_point(field_get:vg.Mapping.edit)
  return edit_.Get(index);
}
inline ::vg::Edit* Mapping::mutable_edit(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Mapping.edit)
  return edit_.Mutable(index);
}
inline ::vg::Edit* Mapping::add_edit() {
  // @@protoc_insertion_point(field_add:vg.Mapping.edit)
  return edit_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Edit >*
Mapping::mutable_edit() {
  // @@protoc_insertion_point(field_mutable_list:vg.Mapping.edit)
  return &edit_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Edit >&
Mapping::edit() const {
  // @@protoc_insertion_point(field_list:vg.Mapping.edit)
  return edit_;
}

// optional int64 rank = 5;
inline void Mapping::clear_rank() {
  rank_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Mapping::rank() const {
  // @@protoc_insertion_point(field_get:vg.Mapping.rank)
  return rank_;
}
inline void Mapping::set_rank(::google::protobuf::int64 value) {
  
  rank_ = value;
  // @@protoc_insertion_point(field_set:vg.Mapping.rank)
}

// -------------------------------------------------------------------

// Position

// optional int64 node_id = 1;
inline void Position::clear_node_id() {
  node_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Position::node_id() const {
  // @@protoc_insertion_point(field_get:vg.Position.node_id)
  return node_id_;
}
inline void Position::set_node_id(::google::protobuf::int64 value) {
  
  node_id_ = value;
  // @@protoc_insertion_point(field_set:vg.Position.node_id)
}

// optional int64 offset = 2;
inline void Position::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Position::offset() const {
  // @@protoc_insertion_point(field_get:vg.Position.offset)
  return offset_;
}
inline void Position::set_offset(::google::protobuf::int64 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:vg.Position.offset)
}

// optional bool is_reverse = 4;
inline void Position::clear_is_reverse() {
  is_reverse_ = false;
}
inline bool Position::is_reverse() const {
  // @@protoc_insertion_point(field_get:vg.Position.is_reverse)
  return is_reverse_;
}
inline void Position::set_is_reverse(bool value) {
  
  is_reverse_ = value;
  // @@protoc_insertion_point(field_set:vg.Position.is_reverse)
}

// optional string name = 5;
inline void Position::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Position::name() const {
  // @@protoc_insertion_point(field_get:vg.Position.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Position::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Position.name)
}
inline void Position::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Position.name)
}
inline void Position::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Position.name)
}
inline ::std::string* Position::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:vg.Position.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Position::release_name() {
  // @@protoc_insertion_point(field_release:vg.Position.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Position::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vg.Position.name)
}

// -------------------------------------------------------------------

// Path

// optional string name = 1;
inline void Path::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Path::name() const {
  // @@protoc_insertion_point(field_get:vg.Path.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Path::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Path.name)
}
inline void Path::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Path.name)
}
inline void Path::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Path.name)
}
inline ::std::string* Path::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:vg.Path.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Path::release_name() {
  // @@protoc_insertion_point(field_release:vg.Path.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Path::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vg.Path.name)
}

// repeated .vg.Mapping mapping = 2;
inline int Path::mapping_size() const {
  return mapping_.size();
}
inline void Path::clear_mapping() {
  mapping_.Clear();
}
inline const ::vg::Mapping& Path::mapping(int index) const {
  // @@protoc_insertion_point(field_get:vg.Path.mapping)
  return mapping_.Get(index);
}
inline ::vg::Mapping* Path::mutable_mapping(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Path.mapping)
  return mapping_.Mutable(index);
}
inline ::vg::Mapping* Path::add_mapping() {
  // @@protoc_insertion_point(field_add:vg.Path.mapping)
  return mapping_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Mapping >*
Path::mutable_mapping() {
  // @@protoc_insertion_point(field_mutable_list:vg.Path.mapping)
  return &mapping_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Mapping >&
Path::mapping() const {
  // @@protoc_insertion_point(field_list:vg.Path.mapping)
  return mapping_;
}

// optional bool is_circular = 3;
inline void Path::clear_is_circular() {
  is_circular_ = false;
}
inline bool Path::is_circular() const {
  // @@protoc_insertion_point(field_get:vg.Path.is_circular)
  return is_circular_;
}
inline void Path::set_is_circular(bool value) {
  
  is_circular_ = value;
  // @@protoc_insertion_point(field_set:vg.Path.is_circular)
}

// optional int64 length = 4;
inline void Path::clear_length() {
  length_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Path::length() const {
  // @@protoc_insertion_point(field_get:vg.Path.length)
  return length_;
}
inline void Path::set_length(::google::protobuf::int64 value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:vg.Path.length)
}

// -------------------------------------------------------------------

// Alignment

// optional string sequence = 1;
inline void Alignment::clear_sequence() {
  sequence_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Alignment::sequence() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.sequence)
  return sequence_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Alignment::set_sequence(const ::std::string& value) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Alignment.sequence)
}
inline void Alignment::set_sequence(const char* value) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Alignment.sequence)
}
inline void Alignment::set_sequence(const char* value, size_t size) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Alignment.sequence)
}
inline ::std::string* Alignment::mutable_sequence() {
  
  // @@protoc_insertion_point(field_mutable:vg.Alignment.sequence)
  return sequence_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Alignment::release_sequence() {
  // @@protoc_insertion_point(field_release:vg.Alignment.sequence)
  
  return sequence_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Alignment::set_allocated_sequence(::std::string* sequence) {
  if (sequence != NULL) {
    
  } else {
    
  }
  sequence_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sequence);
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.sequence)
}

// optional .vg.Path path = 2;
inline bool Alignment::has_path() const {
  return !_is_default_instance_ && path_ != NULL;
}
inline void Alignment::clear_path() {
  if (GetArenaNoVirtual() == NULL && path_ != NULL) delete path_;
  path_ = NULL;
}
inline const ::vg::Path& Alignment::path() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.path)
  return path_ != NULL ? *path_ : *default_instance_->path_;
}
inline ::vg::Path* Alignment::mutable_path() {
  
  if (path_ == NULL) {
    path_ = new ::vg::Path;
  }
  // @@protoc_insertion_point(field_mutable:vg.Alignment.path)
  return path_;
}
inline ::vg::Path* Alignment::release_path() {
  // @@protoc_insertion_point(field_release:vg.Alignment.path)
  
  ::vg::Path* temp = path_;
  path_ = NULL;
  return temp;
}
inline void Alignment::set_allocated_path(::vg::Path* path) {
  delete path_;
  path_ = path;
  if (path) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.path)
}

// optional string name = 3;
inline void Alignment::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Alignment::name() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Alignment::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Alignment.name)
}
inline void Alignment::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Alignment.name)
}
inline void Alignment::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Alignment.name)
}
inline ::std::string* Alignment::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:vg.Alignment.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Alignment::release_name() {
  // @@protoc_insertion_point(field_release:vg.Alignment.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Alignment::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.name)
}

// optional bytes quality = 4;
inline void Alignment::clear_quality() {
  quality_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Alignment::quality() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.quality)
  return quality_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Alignment::set_quality(const ::std::string& value) {
  
  quality_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Alignment.quality)
}
inline void Alignment::set_quality(const char* value) {
  
  quality_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Alignment.quality)
}
inline void Alignment::set_quality(const void* value, size_t size) {
  
  quality_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Alignment.quality)
}
inline ::std::string* Alignment::mutable_quality() {
  
  // @@protoc_insertion_point(field_mutable:vg.Alignment.quality)
  return quality_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Alignment::release_quality() {
  // @@protoc_insertion_point(field_release:vg.Alignment.quality)
  
  return quality_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Alignment::set_allocated_quality(::std::string* quality) {
  if (quality != NULL) {
    
  } else {
    
  }
  quality_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), quality);
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.quality)
}

// optional int32 mapping_quality = 5;
inline void Alignment::clear_mapping_quality() {
  mapping_quality_ = 0;
}
inline ::google::protobuf::int32 Alignment::mapping_quality() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.mapping_quality)
  return mapping_quality_;
}
inline void Alignment::set_mapping_quality(::google::protobuf::int32 value) {
  
  mapping_quality_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.mapping_quality)
}

// optional int32 score = 6;
inline void Alignment::clear_score() {
  score_ = 0;
}
inline ::google::protobuf::int32 Alignment::score() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.score)
  return score_;
}
inline void Alignment::set_score(::google::protobuf::int32 value) {
  
  score_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.score)
}

// optional int32 query_position = 7;
inline void Alignment::clear_query_position() {
  query_position_ = 0;
}
inline ::google::protobuf::int32 Alignment::query_position() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.query_position)
  return query_position_;
}
inline void Alignment::set_query_position(::google::protobuf::int32 value) {
  
  query_position_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.query_position)
}

// optional string sample_name = 9;
inline void Alignment::clear_sample_name() {
  sample_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Alignment::sample_name() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.sample_name)
  return sample_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Alignment::set_sample_name(const ::std::string& value) {
  
  sample_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Alignment.sample_name)
}
inline void Alignment::set_sample_name(const char* value) {
  
  sample_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Alignment.sample_name)
}
inline void Alignment::set_sample_name(const char* value, size_t size) {
  
  sample_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Alignment.sample_name)
}
inline ::std::string* Alignment::mutable_sample_name() {
  
  // @@protoc_insertion_point(field_mutable:vg.Alignment.sample_name)
  return sample_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Alignment::release_sample_name() {
  // @@protoc_insertion_point(field_release:vg.Alignment.sample_name)
  
  return sample_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Alignment::set_allocated_sample_name(::std::string* sample_name) {
  if (sample_name != NULL) {
    
  } else {
    
  }
  sample_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sample_name);
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.sample_name)
}

// optional string read_group = 10;
inline void Alignment::clear_read_group() {
  read_group_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Alignment::read_group() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.read_group)
  return read_group_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Alignment::set_read_group(const ::std::string& value) {
  
  read_group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Alignment.read_group)
}
inline void Alignment::set_read_group(const char* value) {
  
  read_group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Alignment.read_group)
}
inline void Alignment::set_read_group(const char* value, size_t size) {
  
  read_group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Alignment.read_group)
}
inline ::std::string* Alignment::mutable_read_group() {
  
  // @@protoc_insertion_point(field_mutable:vg.Alignment.read_group)
  return read_group_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Alignment::release_read_group() {
  // @@protoc_insertion_point(field_release:vg.Alignment.read_group)
  
  return read_group_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Alignment::set_allocated_read_group(::std::string* read_group) {
  if (read_group != NULL) {
    
  } else {
    
  }
  read_group_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), read_group);
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.read_group)
}

// optional .vg.Alignment fragment_prev = 11;
inline bool Alignment::has_fragment_prev() const {
  return !_is_default_instance_ && fragment_prev_ != NULL;
}
inline void Alignment::clear_fragment_prev() {
  if (GetArenaNoVirtual() == NULL && fragment_prev_ != NULL) delete fragment_prev_;
  fragment_prev_ = NULL;
}
inline const ::vg::Alignment& Alignment::fragment_prev() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.fragment_prev)
  return fragment_prev_ != NULL ? *fragment_prev_ : *default_instance_->fragment_prev_;
}
inline ::vg::Alignment* Alignment::mutable_fragment_prev() {
  
  if (fragment_prev_ == NULL) {
    fragment_prev_ = new ::vg::Alignment;
  }
  // @@protoc_insertion_point(field_mutable:vg.Alignment.fragment_prev)
  return fragment_prev_;
}
inline ::vg::Alignment* Alignment::release_fragment_prev() {
  // @@protoc_insertion_point(field_release:vg.Alignment.fragment_prev)
  
  ::vg::Alignment* temp = fragment_prev_;
  fragment_prev_ = NULL;
  return temp;
}
inline void Alignment::set_allocated_fragment_prev(::vg::Alignment* fragment_prev) {
  delete fragment_prev_;
  fragment_prev_ = fragment_prev;
  if (fragment_prev) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.fragment_prev)
}

// optional .vg.Alignment fragment_next = 12;
inline bool Alignment::has_fragment_next() const {
  return !_is_default_instance_ && fragment_next_ != NULL;
}
inline void Alignment::clear_fragment_next() {
  if (GetArenaNoVirtual() == NULL && fragment_next_ != NULL) delete fragment_next_;
  fragment_next_ = NULL;
}
inline const ::vg::Alignment& Alignment::fragment_next() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.fragment_next)
  return fragment_next_ != NULL ? *fragment_next_ : *default_instance_->fragment_next_;
}
inline ::vg::Alignment* Alignment::mutable_fragment_next() {
  
  if (fragment_next_ == NULL) {
    fragment_next_ = new ::vg::Alignment;
  }
  // @@protoc_insertion_point(field_mutable:vg.Alignment.fragment_next)
  return fragment_next_;
}
inline ::vg::Alignment* Alignment::release_fragment_next() {
  // @@protoc_insertion_point(field_release:vg.Alignment.fragment_next)
  
  ::vg::Alignment* temp = fragment_next_;
  fragment_next_ = NULL;
  return temp;
}
inline void Alignment::set_allocated_fragment_next(::vg::Alignment* fragment_next) {
  delete fragment_next_;
  fragment_next_ = fragment_next;
  if (fragment_next) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.fragment_next)
}

// optional bool is_secondary = 15;
inline void Alignment::clear_is_secondary() {
  is_secondary_ = false;
}
inline bool Alignment::is_secondary() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.is_secondary)
  return is_secondary_;
}
inline void Alignment::set_is_secondary(bool value) {
  
  is_secondary_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.is_secondary)
}

// optional double identity = 16;
inline void Alignment::clear_identity() {
  identity_ = 0;
}
inline double Alignment::identity() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.identity)
  return identity_;
}
inline void Alignment::set_identity(double value) {
  
  identity_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.identity)
}

// repeated .vg.Path fragment = 17;
inline int Alignment::fragment_size() const {
  return fragment_.size();
}
inline void Alignment::clear_fragment() {
  fragment_.Clear();
}
inline const ::vg::Path& Alignment::fragment(int index) const {
  // @@protoc_insertion_point(field_get:vg.Alignment.fragment)
  return fragment_.Get(index);
}
inline ::vg::Path* Alignment::mutable_fragment(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Alignment.fragment)
  return fragment_.Mutable(index);
}
inline ::vg::Path* Alignment::add_fragment() {
  // @@protoc_insertion_point(field_add:vg.Alignment.fragment)
  return fragment_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Path >*
Alignment::mutable_fragment() {
  // @@protoc_insertion_point(field_mutable_list:vg.Alignment.fragment)
  return &fragment_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Path >&
Alignment::fragment() const {
  // @@protoc_insertion_point(field_list:vg.Alignment.fragment)
  return fragment_;
}

// repeated .vg.Locus locus = 18;
inline int Alignment::locus_size() const {
  return locus_.size();
}
inline void Alignment::clear_locus() {
  locus_.Clear();
}
inline const ::vg::Locus& Alignment::locus(int index) const {
  // @@protoc_insertion_point(field_get:vg.Alignment.locus)
  return locus_.Get(index);
}
inline ::vg::Locus* Alignment::mutable_locus(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Alignment.locus)
  return locus_.Mutable(index);
}
inline ::vg::Locus* Alignment::add_locus() {
  // @@protoc_insertion_point(field_add:vg.Alignment.locus)
  return locus_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Locus >*
Alignment::mutable_locus() {
  // @@protoc_insertion_point(field_mutable_list:vg.Alignment.locus)
  return &locus_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Locus >&
Alignment::locus() const {
  // @@protoc_insertion_point(field_list:vg.Alignment.locus)
  return locus_;
}

// repeated .vg.Position refpos = 19;
inline int Alignment::refpos_size() const {
  return refpos_.size();
}
inline void Alignment::clear_refpos() {
  refpos_.Clear();
}
inline const ::vg::Position& Alignment::refpos(int index) const {
  // @@protoc_insertion_point(field_get:vg.Alignment.refpos)
  return refpos_.Get(index);
}
inline ::vg::Position* Alignment::mutable_refpos(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Alignment.refpos)
  return refpos_.Mutable(index);
}
inline ::vg::Position* Alignment::add_refpos() {
  // @@protoc_insertion_point(field_add:vg.Alignment.refpos)
  return refpos_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Position >*
Alignment::mutable_refpos() {
  // @@protoc_insertion_point(field_mutable_list:vg.Alignment.refpos)
  return &refpos_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Position >&
Alignment::refpos() const {
  // @@protoc_insertion_point(field_list:vg.Alignment.refpos)
  return refpos_;
}

// optional bool read_paired = 20;
inline void Alignment::clear_read_paired() {
  read_paired_ = false;
}
inline bool Alignment::read_paired() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.read_paired)
  return read_paired_;
}
inline void Alignment::set_read_paired(bool value) {
  
  read_paired_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.read_paired)
}

// optional bool read_mapped = 21;
inline void Alignment::clear_read_mapped() {
  read_mapped_ = false;
}
inline bool Alignment::read_mapped() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.read_mapped)
  return read_mapped_;
}
inline void Alignment::set_read_mapped(bool value) {
  
  read_mapped_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.read_mapped)
}

// optional bool mate_unmapped = 22;
inline void Alignment::clear_mate_unmapped() {
  mate_unmapped_ = false;
}
inline bool Alignment::mate_unmapped() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.mate_unmapped)
  return mate_unmapped_;
}
inline void Alignment::set_mate_unmapped(bool value) {
  
  mate_unmapped_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.mate_unmapped)
}

// optional bool read_on_reverse_strand = 23;
inline void Alignment::clear_read_on_reverse_strand() {
  read_on_reverse_strand_ = false;
}
inline bool Alignment::read_on_reverse_strand() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.read_on_reverse_strand)
  return read_on_reverse_strand_;
}
inline void Alignment::set_read_on_reverse_strand(bool value) {
  
  read_on_reverse_strand_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.read_on_reverse_strand)
}

// optional bool mate_on_reverse_strand = 24;
inline void Alignment::clear_mate_on_reverse_strand() {
  mate_on_reverse_strand_ = false;
}
inline bool Alignment::mate_on_reverse_strand() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.mate_on_reverse_strand)
  return mate_on_reverse_strand_;
}
inline void Alignment::set_mate_on_reverse_strand(bool value) {
  
  mate_on_reverse_strand_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.mate_on_reverse_strand)
}

// optional bool soft_clipped = 25;
inline void Alignment::clear_soft_clipped() {
  soft_clipped_ = false;
}
inline bool Alignment::soft_clipped() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.soft_clipped)
  return soft_clipped_;
}
inline void Alignment::set_soft_clipped(bool value) {
  
  soft_clipped_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.soft_clipped)
}

// optional bool discordant_insert_size = 26;
inline void Alignment::clear_discordant_insert_size() {
  discordant_insert_size_ = false;
}
inline bool Alignment::discordant_insert_size() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.discordant_insert_size)
  return discordant_insert_size_;
}
inline void Alignment::set_discordant_insert_size(bool value) {
  
  discordant_insert_size_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.discordant_insert_size)
}

// optional double uniqueness = 27;
inline void Alignment::clear_uniqueness() {
  uniqueness_ = 0;
}
inline double Alignment::uniqueness() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.uniqueness)
  return uniqueness_;
}
inline void Alignment::set_uniqueness(double value) {
  
  uniqueness_ = value;
  // @@protoc_insertion_point(field_set:vg.Alignment.uniqueness)
}

// -------------------------------------------------------------------

// MultipathAlignment

// optional string sequence = 1;
inline void MultipathAlignment::clear_sequence() {
  sequence_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MultipathAlignment::sequence() const {
  // @@protoc_insertion_point(field_get:vg.MultipathAlignment.sequence)
  return sequence_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MultipathAlignment::set_sequence(const ::std::string& value) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.MultipathAlignment.sequence)
}
inline void MultipathAlignment::set_sequence(const char* value) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.MultipathAlignment.sequence)
}
inline void MultipathAlignment::set_sequence(const char* value, size_t size) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.MultipathAlignment.sequence)
}
inline ::std::string* MultipathAlignment::mutable_sequence() {
  
  // @@protoc_insertion_point(field_mutable:vg.MultipathAlignment.sequence)
  return sequence_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MultipathAlignment::release_sequence() {
  // @@protoc_insertion_point(field_release:vg.MultipathAlignment.sequence)
  
  return sequence_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MultipathAlignment::set_allocated_sequence(::std::string* sequence) {
  if (sequence != NULL) {
    
  } else {
    
  }
  sequence_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sequence);
  // @@protoc_insertion_point(field_set_allocated:vg.MultipathAlignment.sequence)
}

// optional bytes quality = 2;
inline void MultipathAlignment::clear_quality() {
  quality_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MultipathAlignment::quality() const {
  // @@protoc_insertion_point(field_get:vg.MultipathAlignment.quality)
  return quality_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MultipathAlignment::set_quality(const ::std::string& value) {
  
  quality_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.MultipathAlignment.quality)
}
inline void MultipathAlignment::set_quality(const char* value) {
  
  quality_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.MultipathAlignment.quality)
}
inline void MultipathAlignment::set_quality(const void* value, size_t size) {
  
  quality_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.MultipathAlignment.quality)
}
inline ::std::string* MultipathAlignment::mutable_quality() {
  
  // @@protoc_insertion_point(field_mutable:vg.MultipathAlignment.quality)
  return quality_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MultipathAlignment::release_quality() {
  // @@protoc_insertion_point(field_release:vg.MultipathAlignment.quality)
  
  return quality_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MultipathAlignment::set_allocated_quality(::std::string* quality) {
  if (quality != NULL) {
    
  } else {
    
  }
  quality_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), quality);
  // @@protoc_insertion_point(field_set_allocated:vg.MultipathAlignment.quality)
}

// optional string name = 3;
inline void MultipathAlignment::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MultipathAlignment::name() const {
  // @@protoc_insertion_point(field_get:vg.MultipathAlignment.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MultipathAlignment::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.MultipathAlignment.name)
}
inline void MultipathAlignment::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.MultipathAlignment.name)
}
inline void MultipathAlignment::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.MultipathAlignment.name)
}
inline ::std::string* MultipathAlignment::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:vg.MultipathAlignment.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MultipathAlignment::release_name() {
  // @@protoc_insertion_point(field_release:vg.MultipathAlignment.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MultipathAlignment::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vg.MultipathAlignment.name)
}

// optional string sample_name = 4;
inline void MultipathAlignment::clear_sample_name() {
  sample_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MultipathAlignment::sample_name() const {
  // @@protoc_insertion_point(field_get:vg.MultipathAlignment.sample_name)
  return sample_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MultipathAlignment::set_sample_name(const ::std::string& value) {
  
  sample_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.MultipathAlignment.sample_name)
}
inline void MultipathAlignment::set_sample_name(const char* value) {
  
  sample_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.MultipathAlignment.sample_name)
}
inline void MultipathAlignment::set_sample_name(const char* value, size_t size) {
  
  sample_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.MultipathAlignment.sample_name)
}
inline ::std::string* MultipathAlignment::mutable_sample_name() {
  
  // @@protoc_insertion_point(field_mutable:vg.MultipathAlignment.sample_name)
  return sample_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MultipathAlignment::release_sample_name() {
  // @@protoc_insertion_point(field_release:vg.MultipathAlignment.sample_name)
  
  return sample_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MultipathAlignment::set_allocated_sample_name(::std::string* sample_name) {
  if (sample_name != NULL) {
    
  } else {
    
  }
  sample_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sample_name);
  // @@protoc_insertion_point(field_set_allocated:vg.MultipathAlignment.sample_name)
}

// optional string read_group = 5;
inline void MultipathAlignment::clear_read_group() {
  read_group_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MultipathAlignment::read_group() const {
  // @@protoc_insertion_point(field_get:vg.MultipathAlignment.read_group)
  return read_group_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MultipathAlignment::set_read_group(const ::std::string& value) {
  
  read_group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.MultipathAlignment.read_group)
}
inline void MultipathAlignment::set_read_group(const char* value) {
  
  read_group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.MultipathAlignment.read_group)
}
inline void MultipathAlignment::set_read_group(const char* value, size_t size) {
  
  read_group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.MultipathAlignment.read_group)
}
inline ::std::string* MultipathAlignment::mutable_read_group() {
  
  // @@protoc_insertion_point(field_mutable:vg.MultipathAlignment.read_group)
  return read_group_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MultipathAlignment::release_read_group() {
  // @@protoc_insertion_point(field_release:vg.MultipathAlignment.read_group)
  
  return read_group_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MultipathAlignment::set_allocated_read_group(::std::string* read_group) {
  if (read_group != NULL) {
    
  } else {
    
  }
  read_group_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), read_group);
  // @@protoc_insertion_point(field_set_allocated:vg.MultipathAlignment.read_group)
}

// repeated .vg.Subpath subpath = 6;
inline int MultipathAlignment::subpath_size() const {
  return subpath_.size();
}
inline void MultipathAlignment::clear_subpath() {
  subpath_.Clear();
}
inline const ::vg::Subpath& MultipathAlignment::subpath(int index) const {
  // @@protoc_insertion_point(field_get:vg.MultipathAlignment.subpath)
  return subpath_.Get(index);
}
inline ::vg::Subpath* MultipathAlignment::mutable_subpath(int index) {
  // @@protoc_insertion_point(field_mutable:vg.MultipathAlignment.subpath)
  return subpath_.Mutable(index);
}
inline ::vg::Subpath* MultipathAlignment::add_subpath() {
  // @@protoc_insertion_point(field_add:vg.MultipathAlignment.subpath)
  return subpath_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Subpath >*
MultipathAlignment::mutable_subpath() {
  // @@protoc_insertion_point(field_mutable_list:vg.MultipathAlignment.subpath)
  return &subpath_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Subpath >&
MultipathAlignment::subpath() const {
  // @@protoc_insertion_point(field_list:vg.MultipathAlignment.subpath)
  return subpath_;
}

// optional int32 mapping_quality = 7;
inline void MultipathAlignment::clear_mapping_quality() {
  mapping_quality_ = 0;
}
inline ::google::protobuf::int32 MultipathAlignment::mapping_quality() const {
  // @@protoc_insertion_point(field_get:vg.MultipathAlignment.mapping_quality)
  return mapping_quality_;
}
inline void MultipathAlignment::set_mapping_quality(::google::protobuf::int32 value) {
  
  mapping_quality_ = value;
  // @@protoc_insertion_point(field_set:vg.MultipathAlignment.mapping_quality)
}

// repeated uint32 start = 8;
inline int MultipathAlignment::start_size() const {
  return start_.size();
}
inline void MultipathAlignment::clear_start() {
  start_.Clear();
}
inline ::google::protobuf::uint32 MultipathAlignment::start(int index) const {
  // @@protoc_insertion_point(field_get:vg.MultipathAlignment.start)
  return start_.Get(index);
}
inline void MultipathAlignment::set_start(int index, ::google::protobuf::uint32 value) {
  start_.Set(index, value);
  // @@protoc_insertion_point(field_set:vg.MultipathAlignment.start)
}
inline void MultipathAlignment::add_start(::google::protobuf::uint32 value) {
  start_.Add(value);
  // @@protoc_insertion_point(field_add:vg.MultipathAlignment.start)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MultipathAlignment::start() const {
  // @@protoc_insertion_point(field_list:vg.MultipathAlignment.start)
  return start_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MultipathAlignment::mutable_start() {
  // @@protoc_insertion_point(field_mutable_list:vg.MultipathAlignment.start)
  return &start_;
}

// -------------------------------------------------------------------

// Subpath

// optional .vg.Path path = 1;
inline bool Subpath::has_path() const {
  return !_is_default_instance_ && path_ != NULL;
}
inline void Subpath::clear_path() {
  if (GetArenaNoVirtual() == NULL && path_ != NULL) delete path_;
  path_ = NULL;
}
inline const ::vg::Path& Subpath::path() const {
  // @@protoc_insertion_point(field_get:vg.Subpath.path)
  return path_ != NULL ? *path_ : *default_instance_->path_;
}
inline ::vg::Path* Subpath::mutable_path() {
  
  if (path_ == NULL) {
    path_ = new ::vg::Path;
  }
  // @@protoc_insertion_point(field_mutable:vg.Subpath.path)
  return path_;
}
inline ::vg::Path* Subpath::release_path() {
  // @@protoc_insertion_point(field_release:vg.Subpath.path)
  
  ::vg::Path* temp = path_;
  path_ = NULL;
  return temp;
}
inline void Subpath::set_allocated_path(::vg::Path* path) {
  delete path_;
  path_ = path;
  if (path) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:vg.Subpath.path)
}

// repeated uint32 next = 2;
inline int Subpath::next_size() const {
  return next_.size();
}
inline void Subpath::clear_next() {
  next_.Clear();
}
inline ::google::protobuf::uint32 Subpath::next(int index) const {
  // @@protoc_insertion_point(field_get:vg.Subpath.next)
  return next_.Get(index);
}
inline void Subpath::set_next(int index, ::google::protobuf::uint32 value) {
  next_.Set(index, value);
  // @@protoc_insertion_point(field_set:vg.Subpath.next)
}
inline void Subpath::add_next(::google::protobuf::uint32 value) {
  next_.Add(value);
  // @@protoc_insertion_point(field_add:vg.Subpath.next)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Subpath::next() const {
  // @@protoc_insertion_point(field_list:vg.Subpath.next)
  return next_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Subpath::mutable_next() {
  // @@protoc_insertion_point(field_mutable_list:vg.Subpath.next)
  return &next_;
}

// optional int32 score = 3;
inline void Subpath::clear_score() {
  score_ = 0;
}
inline ::google::protobuf::int32 Subpath::score() const {
  // @@protoc_insertion_point(field_get:vg.Subpath.score)
  return score_;
}
inline void Subpath::set_score(::google::protobuf::int32 value) {
  
  score_ = value;
  // @@protoc_insertion_point(field_set:vg.Subpath.score)
}

// -------------------------------------------------------------------

// KmerMatch

// optional string sequence = 1;
inline void KmerMatch::clear_sequence() {
  sequence_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KmerMatch::sequence() const {
  // @@protoc_insertion_point(field_get:vg.KmerMatch.sequence)
  return sequence_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KmerMatch::set_sequence(const ::std::string& value) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.KmerMatch.sequence)
}
inline void KmerMatch::set_sequence(const char* value) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.KmerMatch.sequence)
}
inline void KmerMatch::set_sequence(const char* value, size_t size) {
  
  sequence_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.KmerMatch.sequence)
}
inline ::std::string* KmerMatch::mutable_sequence() {
  
  // @@protoc_insertion_point(field_mutable:vg.KmerMatch.sequence)
  return sequence_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KmerMatch::release_sequence() {
  // @@protoc_insertion_point(field_release:vg.KmerMatch.sequence)
  
  return sequence_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KmerMatch::set_allocated_sequence(::std::string* sequence) {
  if (sequence != NULL) {
    
  } else {
    
  }
  sequence_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sequence);
  // @@protoc_insertion_point(field_set_allocated:vg.KmerMatch.sequence)
}

// optional int64 node_id = 2;
inline void KmerMatch::clear_node_id() {
  node_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 KmerMatch::node_id() const {
  // @@protoc_insertion_point(field_get:vg.KmerMatch.node_id)
  return node_id_;
}
inline void KmerMatch::set_node_id(::google::protobuf::int64 value) {
  
  node_id_ = value;
  // @@protoc_insertion_point(field_set:vg.KmerMatch.node_id)
}

// optional sint32 position = 3;
inline void KmerMatch::clear_position() {
  position_ = 0;
}
inline ::google::protobuf::int32 KmerMatch::position() const {
  // @@protoc_insertion_point(field_get:vg.KmerMatch.position)
  return position_;
}
inline void KmerMatch::set_position(::google::protobuf::int32 value) {
  
  position_ = value;
  // @@protoc_insertion_point(field_set:vg.KmerMatch.position)
}

// optional bool backward = 4;
inline void KmerMatch::clear_backward() {
  backward_ = false;
}
inline bool KmerMatch::backward() const {
  // @@protoc_insertion_point(field_get:vg.KmerMatch.backward)
  return backward_;
}
inline void KmerMatch::set_backward(bool value) {
  
  backward_ = value;
  // @@protoc_insertion_point(field_set:vg.KmerMatch.backward)
}

// -------------------------------------------------------------------

// BasePileup

// optional int32 ref_base = 1;
inline void BasePileup::clear_ref_base() {
  ref_base_ = 0;
}
inline ::google::protobuf::int32 BasePileup::ref_base() const {
  // @@protoc_insertion_point(field_get:vg.BasePileup.ref_base)
  return ref_base_;
}
inline void BasePileup::set_ref_base(::google::protobuf::int32 value) {
  
  ref_base_ = value;
  // @@protoc_insertion_point(field_set:vg.BasePileup.ref_base)
}

// optional int32 num_bases = 2;
inline void BasePileup::clear_num_bases() {
  num_bases_ = 0;
}
inline ::google::protobuf::int32 BasePileup::num_bases() const {
  // @@protoc_insertion_point(field_get:vg.BasePileup.num_bases)
  return num_bases_;
}
inline void BasePileup::set_num_bases(::google::protobuf::int32 value) {
  
  num_bases_ = value;
  // @@protoc_insertion_point(field_set:vg.BasePileup.num_bases)
}

// optional string bases = 3;
inline void BasePileup::clear_bases() {
  bases_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BasePileup::bases() const {
  // @@protoc_insertion_point(field_get:vg.BasePileup.bases)
  return bases_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BasePileup::set_bases(const ::std::string& value) {
  
  bases_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.BasePileup.bases)
}
inline void BasePileup::set_bases(const char* value) {
  
  bases_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.BasePileup.bases)
}
inline void BasePileup::set_bases(const char* value, size_t size) {
  
  bases_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.BasePileup.bases)
}
inline ::std::string* BasePileup::mutable_bases() {
  
  // @@protoc_insertion_point(field_mutable:vg.BasePileup.bases)
  return bases_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BasePileup::release_bases() {
  // @@protoc_insertion_point(field_release:vg.BasePileup.bases)
  
  return bases_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BasePileup::set_allocated_bases(::std::string* bases) {
  if (bases != NULL) {
    
  } else {
    
  }
  bases_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bases);
  // @@protoc_insertion_point(field_set_allocated:vg.BasePileup.bases)
}

// optional bytes qualities = 4;
inline void BasePileup::clear_qualities() {
  qualities_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BasePileup::qualities() const {
  // @@protoc_insertion_point(field_get:vg.BasePileup.qualities)
  return qualities_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BasePileup::set_qualities(const ::std::string& value) {
  
  qualities_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.BasePileup.qualities)
}
inline void BasePileup::set_qualities(const char* value) {
  
  qualities_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.BasePileup.qualities)
}
inline void BasePileup::set_qualities(const void* value, size_t size) {
  
  qualities_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.BasePileup.qualities)
}
inline ::std::string* BasePileup::mutable_qualities() {
  
  // @@protoc_insertion_point(field_mutable:vg.BasePileup.qualities)
  return qualities_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BasePileup::release_qualities() {
  // @@protoc_insertion_point(field_release:vg.BasePileup.qualities)
  
  return qualities_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BasePileup::set_allocated_qualities(::std::string* qualities) {
  if (qualities != NULL) {
    
  } else {
    
  }
  qualities_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), qualities);
  // @@protoc_insertion_point(field_set_allocated:vg.BasePileup.qualities)
}

// -------------------------------------------------------------------

// NodePileup

// optional int64 node_id = 1;
inline void NodePileup::clear_node_id() {
  node_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 NodePileup::node_id() const {
  // @@protoc_insertion_point(field_get:vg.NodePileup.node_id)
  return node_id_;
}
inline void NodePileup::set_node_id(::google::protobuf::int64 value) {
  
  node_id_ = value;
  // @@protoc_insertion_point(field_set:vg.NodePileup.node_id)
}

// repeated .vg.BasePileup base_pileup = 2;
inline int NodePileup::base_pileup_size() const {
  return base_pileup_.size();
}
inline void NodePileup::clear_base_pileup() {
  base_pileup_.Clear();
}
inline const ::vg::BasePileup& NodePileup::base_pileup(int index) const {
  // @@protoc_insertion_point(field_get:vg.NodePileup.base_pileup)
  return base_pileup_.Get(index);
}
inline ::vg::BasePileup* NodePileup::mutable_base_pileup(int index) {
  // @@protoc_insertion_point(field_mutable:vg.NodePileup.base_pileup)
  return base_pileup_.Mutable(index);
}
inline ::vg::BasePileup* NodePileup::add_base_pileup() {
  // @@protoc_insertion_point(field_add:vg.NodePileup.base_pileup)
  return base_pileup_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vg::BasePileup >*
NodePileup::mutable_base_pileup() {
  // @@protoc_insertion_point(field_mutable_list:vg.NodePileup.base_pileup)
  return &base_pileup_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::BasePileup >&
NodePileup::base_pileup() const {
  // @@protoc_insertion_point(field_list:vg.NodePileup.base_pileup)
  return base_pileup_;
}

// -------------------------------------------------------------------

// EdgePileup

// optional .vg.Edge edge = 1;
inline bool EdgePileup::has_edge() const {
  return !_is_default_instance_ && edge_ != NULL;
}
inline void EdgePileup::clear_edge() {
  if (GetArenaNoVirtual() == NULL && edge_ != NULL) delete edge_;
  edge_ = NULL;
}
inline const ::vg::Edge& EdgePileup::edge() const {
  // @@protoc_insertion_point(field_get:vg.EdgePileup.edge)
  return edge_ != NULL ? *edge_ : *default_instance_->edge_;
}
inline ::vg::Edge* EdgePileup::mutable_edge() {
  
  if (edge_ == NULL) {
    edge_ = new ::vg::Edge;
  }
  // @@protoc_insertion_point(field_mutable:vg.EdgePileup.edge)
  return edge_;
}
inline ::vg::Edge* EdgePileup::release_edge() {
  // @@protoc_insertion_point(field_release:vg.EdgePileup.edge)
  
  ::vg::Edge* temp = edge_;
  edge_ = NULL;
  return temp;
}
inline void EdgePileup::set_allocated_edge(::vg::Edge* edge) {
  delete edge_;
  edge_ = edge;
  if (edge) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:vg.EdgePileup.edge)
}

// optional int32 num_reads = 2;
inline void EdgePileup::clear_num_reads() {
  num_reads_ = 0;
}
inline ::google::protobuf::int32 EdgePileup::num_reads() const {
  // @@protoc_insertion_point(field_get:vg.EdgePileup.num_reads)
  return num_reads_;
}
inline void EdgePileup::set_num_reads(::google::protobuf::int32 value) {
  
  num_reads_ = value;
  // @@protoc_insertion_point(field_set:vg.EdgePileup.num_reads)
}

// optional int32 num_forward_reads = 3;
inline void EdgePileup::clear_num_forward_reads() {
  num_forward_reads_ = 0;
}
inline ::google::protobuf::int32 EdgePileup::num_forward_reads() const {
  // @@protoc_insertion_point(field_get:vg.EdgePileup.num_forward_reads)
  return num_forward_reads_;
}
inline void EdgePileup::set_num_forward_reads(::google::protobuf::int32 value) {
  
  num_forward_reads_ = value;
  // @@protoc_insertion_point(field_set:vg.EdgePileup.num_forward_reads)
}

// optional bytes qualities = 4;
inline void EdgePileup::clear_qualities() {
  qualities_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EdgePileup::qualities() const {
  // @@protoc_insertion_point(field_get:vg.EdgePileup.qualities)
  return qualities_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EdgePileup::set_qualities(const ::std::string& value) {
  
  qualities_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.EdgePileup.qualities)
}
inline void EdgePileup::set_qualities(const char* value) {
  
  qualities_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.EdgePileup.qualities)
}
inline void EdgePileup::set_qualities(const void* value, size_t size) {
  
  qualities_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.EdgePileup.qualities)
}
inline ::std::string* EdgePileup::mutable_qualities() {
  
  // @@protoc_insertion_point(field_mutable:vg.EdgePileup.qualities)
  return qualities_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EdgePileup::release_qualities() {
  // @@protoc_insertion_point(field_release:vg.EdgePileup.qualities)
  
  return qualities_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EdgePileup::set_allocated_qualities(::std::string* qualities) {
  if (qualities != NULL) {
    
  } else {
    
  }
  qualities_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), qualities);
  // @@protoc_insertion_point(field_set_allocated:vg.EdgePileup.qualities)
}

// -------------------------------------------------------------------

// Pileup

// repeated .vg.NodePileup node_pileups = 1;
inline int Pileup::node_pileups_size() const {
  return node_pileups_.size();
}
inline void Pileup::clear_node_pileups() {
  node_pileups_.Clear();
}
inline const ::vg::NodePileup& Pileup::node_pileups(int index) const {
  // @@protoc_insertion_point(field_get:vg.Pileup.node_pileups)
  return node_pileups_.Get(index);
}
inline ::vg::NodePileup* Pileup::mutable_node_pileups(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Pileup.node_pileups)
  return node_pileups_.Mutable(index);
}
inline ::vg::NodePileup* Pileup::add_node_pileups() {
  // @@protoc_insertion_point(field_add:vg.Pileup.node_pileups)
  return node_pileups_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vg::NodePileup >*
Pileup::mutable_node_pileups() {
  // @@protoc_insertion_point(field_mutable_list:vg.Pileup.node_pileups)
  return &node_pileups_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::NodePileup >&
Pileup::node_pileups() const {
  // @@protoc_insertion_point(field_list:vg.Pileup.node_pileups)
  return node_pileups_;
}

// repeated .vg.EdgePileup edge_pileups = 2;
inline int Pileup::edge_pileups_size() const {
  return edge_pileups_.size();
}
inline void Pileup::clear_edge_pileups() {
  edge_pileups_.Clear();
}
inline const ::vg::EdgePileup& Pileup::edge_pileups(int index) const {
  // @@protoc_insertion_point(field_get:vg.Pileup.edge_pileups)
  return edge_pileups_.Get(index);
}
inline ::vg::EdgePileup* Pileup::mutable_edge_pileups(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Pileup.edge_pileups)
  return edge_pileups_.Mutable(index);
}
inline ::vg::EdgePileup* Pileup::add_edge_pileups() {
  // @@protoc_insertion_point(field_add:vg.Pileup.edge_pileups)
  return edge_pileups_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vg::EdgePileup >*
Pileup::mutable_edge_pileups() {
  // @@protoc_insertion_point(field_mutable_list:vg.Pileup.edge_pileups)
  return &edge_pileups_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::EdgePileup >&
Pileup::edge_pileups() const {
  // @@protoc_insertion_point(field_list:vg.Pileup.edge_pileups)
  return edge_pileups_;
}

// -------------------------------------------------------------------

// Snarl

// optional .vg.SnarlType type = 1;
inline void Snarl::clear_type() {
  type_ = 0;
}
inline ::vg::SnarlType Snarl::type() const {
  // @@protoc_insertion_point(field_get:vg.Snarl.type)
  return static_cast< ::vg::SnarlType >(type_);
}
inline void Snarl::set_type(::vg::SnarlType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:vg.Snarl.type)
}

// optional .vg.Visit start = 2;
inline bool Snarl::has_start() const {
  return !_is_default_instance_ && start_ != NULL;
}
inline void Snarl::clear_start() {
  if (GetArenaNoVirtual() == NULL && start_ != NULL) delete start_;
  start_ = NULL;
}
inline const ::vg::Visit& Snarl::start() const {
  // @@protoc_insertion_point(field_get:vg.Snarl.start)
  return start_ != NULL ? *start_ : *default_instance_->start_;
}
inline ::vg::Visit* Snarl::mutable_start() {
  
  if (start_ == NULL) {
    start_ = new ::vg::Visit;
  }
  // @@protoc_insertion_point(field_mutable:vg.Snarl.start)
  return start_;
}
inline ::vg::Visit* Snarl::release_start() {
  // @@protoc_insertion_point(field_release:vg.Snarl.start)
  
  ::vg::Visit* temp = start_;
  start_ = NULL;
  return temp;
}
inline void Snarl::set_allocated_start(::vg::Visit* start) {
  delete start_;
  start_ = start;
  if (start) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:vg.Snarl.start)
}

// optional .vg.Visit end = 3;
inline bool Snarl::has_end() const {
  return !_is_default_instance_ && end_ != NULL;
}
inline void Snarl::clear_end() {
  if (GetArenaNoVirtual() == NULL && end_ != NULL) delete end_;
  end_ = NULL;
}
inline const ::vg::Visit& Snarl::end() const {
  // @@protoc_insertion_point(field_get:vg.Snarl.end)
  return end_ != NULL ? *end_ : *default_instance_->end_;
}
inline ::vg::Visit* Snarl::mutable_end() {
  
  if (end_ == NULL) {
    end_ = new ::vg::Visit;
  }
  // @@protoc_insertion_point(field_mutable:vg.Snarl.end)
  return end_;
}
inline ::vg::Visit* Snarl::release_end() {
  // @@protoc_insertion_point(field_release:vg.Snarl.end)
  
  ::vg::Visit* temp = end_;
  end_ = NULL;
  return temp;
}
inline void Snarl::set_allocated_end(::vg::Visit* end) {
  delete end_;
  end_ = end;
  if (end) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:vg.Snarl.end)
}

// optional .vg.Snarl parent = 4;
inline bool Snarl::has_parent() const {
  return !_is_default_instance_ && parent_ != NULL;
}
inline void Snarl::clear_parent() {
  if (GetArenaNoVirtual() == NULL && parent_ != NULL) delete parent_;
  parent_ = NULL;
}
inline const ::vg::Snarl& Snarl::parent() const {
  // @@protoc_insertion_point(field_get:vg.Snarl.parent)
  return parent_ != NULL ? *parent_ : *default_instance_->parent_;
}
inline ::vg::Snarl* Snarl::mutable_parent() {
  
  if (parent_ == NULL) {
    parent_ = new ::vg::Snarl;
  }
  // @@protoc_insertion_point(field_mutable:vg.Snarl.parent)
  return parent_;
}
inline ::vg::Snarl* Snarl::release_parent() {
  // @@protoc_insertion_point(field_release:vg.Snarl.parent)
  
  ::vg::Snarl* temp = parent_;
  parent_ = NULL;
  return temp;
}
inline void Snarl::set_allocated_parent(::vg::Snarl* parent) {
  delete parent_;
  parent_ = parent;
  if (parent) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:vg.Snarl.parent)
}

// optional string name = 5;
inline void Snarl::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Snarl::name() const {
  // @@protoc_insertion_point(field_get:vg.Snarl.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Snarl::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Snarl.name)
}
inline void Snarl::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Snarl.name)
}
inline void Snarl::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Snarl.name)
}
inline ::std::string* Snarl::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:vg.Snarl.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Snarl::release_name() {
  // @@protoc_insertion_point(field_release:vg.Snarl.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Snarl::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vg.Snarl.name)
}

// -------------------------------------------------------------------

// Visit

// optional int64 node_id = 1;
inline void Visit::clear_node_id() {
  node_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Visit::node_id() const {
  // @@protoc_insertion_point(field_get:vg.Visit.node_id)
  return node_id_;
}
inline void Visit::set_node_id(::google::protobuf::int64 value) {
  
  node_id_ = value;
  // @@protoc_insertion_point(field_set:vg.Visit.node_id)
}

// optional .vg.Snarl snarl = 2;
inline bool Visit::has_snarl() const {
  return !_is_default_instance_ && snarl_ != NULL;
}
inline void Visit::clear_snarl() {
  if (GetArenaNoVirtual() == NULL && snarl_ != NULL) delete snarl_;
  snarl_ = NULL;
}
inline const ::vg::Snarl& Visit::snarl() const {
  // @@protoc_insertion_point(field_get:vg.Visit.snarl)
  return snarl_ != NULL ? *snarl_ : *default_instance_->snarl_;
}
inline ::vg::Snarl* Visit::mutable_snarl() {
  
  if (snarl_ == NULL) {
    snarl_ = new ::vg::Snarl;
  }
  // @@protoc_insertion_point(field_mutable:vg.Visit.snarl)
  return snarl_;
}
inline ::vg::Snarl* Visit::release_snarl() {
  // @@protoc_insertion_point(field_release:vg.Visit.snarl)
  
  ::vg::Snarl* temp = snarl_;
  snarl_ = NULL;
  return temp;
}
inline void Visit::set_allocated_snarl(::vg::Snarl* snarl) {
  delete snarl_;
  snarl_ = snarl;
  if (snarl) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:vg.Visit.snarl)
}

// optional bool backward = 3;
inline void Visit::clear_backward() {
  backward_ = false;
}
inline bool Visit::backward() const {
  // @@protoc_insertion_point(field_get:vg.Visit.backward)
  return backward_;
}
inline void Visit::set_backward(bool value) {
  
  backward_ = value;
  // @@protoc_insertion_point(field_set:vg.Visit.backward)
}

// -------------------------------------------------------------------

// SnarlTraversal

// repeated .vg.Visit visits = 1;
inline int SnarlTraversal::visits_size() const {
  return visits_.size();
}
inline void SnarlTraversal::clear_visits() {
  visits_.Clear();
}
inline const ::vg::Visit& SnarlTraversal::visits(int index) const {
  // @@protoc_insertion_point(field_get:vg.SnarlTraversal.visits)
  return visits_.Get(index);
}
inline ::vg::Visit* SnarlTraversal::mutable_visits(int index) {
  // @@protoc_insertion_point(field_mutable:vg.SnarlTraversal.visits)
  return visits_.Mutable(index);
}
inline ::vg::Visit* SnarlTraversal::add_visits() {
  // @@protoc_insertion_point(field_add:vg.SnarlTraversal.visits)
  return visits_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Visit >*
SnarlTraversal::mutable_visits() {
  // @@protoc_insertion_point(field_mutable_list:vg.SnarlTraversal.visits)
  return &visits_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Visit >&
SnarlTraversal::visits() const {
  // @@protoc_insertion_point(field_list:vg.SnarlTraversal.visits)
  return visits_;
}

// optional .vg.Snarl snarl = 2;
inline bool SnarlTraversal::has_snarl() const {
  return !_is_default_instance_ && snarl_ != NULL;
}
inline void SnarlTraversal::clear_snarl() {
  if (GetArenaNoVirtual() == NULL && snarl_ != NULL) delete snarl_;
  snarl_ = NULL;
}
inline const ::vg::Snarl& SnarlTraversal::snarl() const {
  // @@protoc_insertion_point(field_get:vg.SnarlTraversal.snarl)
  return snarl_ != NULL ? *snarl_ : *default_instance_->snarl_;
}
inline ::vg::Snarl* SnarlTraversal::mutable_snarl() {
  
  if (snarl_ == NULL) {
    snarl_ = new ::vg::Snarl;
  }
  // @@protoc_insertion_point(field_mutable:vg.SnarlTraversal.snarl)
  return snarl_;
}
inline ::vg::Snarl* SnarlTraversal::release_snarl() {
  // @@protoc_insertion_point(field_release:vg.SnarlTraversal.snarl)
  
  ::vg::Snarl* temp = snarl_;
  snarl_ = NULL;
  return temp;
}
inline void SnarlTraversal::set_allocated_snarl(::vg::Snarl* snarl) {
  delete snarl_;
  snarl_ = snarl;
  if (snarl) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:vg.SnarlTraversal.snarl)
}

// optional string name = 3;
inline void SnarlTraversal::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SnarlTraversal::name() const {
  // @@protoc_insertion_point(field_get:vg.SnarlTraversal.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SnarlTraversal::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.SnarlTraversal.name)
}
inline void SnarlTraversal::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.SnarlTraversal.name)
}
inline void SnarlTraversal::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.SnarlTraversal.name)
}
inline ::std::string* SnarlTraversal::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:vg.SnarlTraversal.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SnarlTraversal::release_name() {
  // @@protoc_insertion_point(field_release:vg.SnarlTraversal.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SnarlTraversal::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vg.SnarlTraversal.name)
}

// -------------------------------------------------------------------

// Locus

// optional string name = 1;
inline void Locus::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Locus::name() const {
  // @@protoc_insertion_point(field_get:vg.Locus.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Locus::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vg.Locus.name)
}
inline void Locus::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vg.Locus.name)
}
inline void Locus::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vg.Locus.name)
}
inline ::std::string* Locus::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:vg.Locus.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Locus::release_name() {
  // @@protoc_insertion_point(field_release:vg.Locus.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Locus::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:vg.Locus.name)
}

// repeated .vg.Path allele = 2;
inline int Locus::allele_size() const {
  return allele_.size();
}
inline void Locus::clear_allele() {
  allele_.Clear();
}
inline const ::vg::Path& Locus::allele(int index) const {
  // @@protoc_insertion_point(field_get:vg.Locus.allele)
  return allele_.Get(index);
}
inline ::vg::Path* Locus::mutable_allele(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Locus.allele)
  return allele_.Mutable(index);
}
inline ::vg::Path* Locus::add_allele() {
  // @@protoc_insertion_point(field_add:vg.Locus.allele)
  return allele_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Path >*
Locus::mutable_allele() {
  // @@protoc_insertion_point(field_mutable_list:vg.Locus.allele)
  return &allele_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Path >&
Locus::allele() const {
  // @@protoc_insertion_point(field_list:vg.Locus.allele)
  return allele_;
}

// repeated .vg.Support support = 3;
inline int Locus::support_size() const {
  return support_.size();
}
inline void Locus::clear_support() {
  support_.Clear();
}
inline const ::vg::Support& Locus::support(int index) const {
  // @@protoc_insertion_point(field_get:vg.Locus.support)
  return support_.Get(index);
}
inline ::vg::Support* Locus::mutable_support(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Locus.support)
  return support_.Mutable(index);
}
inline ::vg::Support* Locus::add_support() {
  // @@protoc_insertion_point(field_add:vg.Locus.support)
  return support_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Support >*
Locus::mutable_support() {
  // @@protoc_insertion_point(field_mutable_list:vg.Locus.support)
  return &support_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Support >&
Locus::support() const {
  // @@protoc_insertion_point(field_list:vg.Locus.support)
  return support_;
}

// repeated .vg.Genotype genotype = 4;
inline int Locus::genotype_size() const {
  return genotype_.size();
}
inline void Locus::clear_genotype() {
  genotype_.Clear();
}
inline const ::vg::Genotype& Locus::genotype(int index) const {
  // @@protoc_insertion_point(field_get:vg.Locus.genotype)
  return genotype_.Get(index);
}
inline ::vg::Genotype* Locus::mutable_genotype(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Locus.genotype)
  return genotype_.Mutable(index);
}
inline ::vg::Genotype* Locus::add_genotype() {
  // @@protoc_insertion_point(field_add:vg.Locus.genotype)
  return genotype_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vg::Genotype >*
Locus::mutable_genotype() {
  // @@protoc_insertion_point(field_mutable_list:vg.Locus.genotype)
  return &genotype_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vg::Genotype >&
Locus::genotype() const {
  // @@protoc_insertion_point(field_list:vg.Locus.genotype)
  return genotype_;
}

// optional .vg.Support overall_support = 5;
inline bool Locus::has_overall_support() const {
  return !_is_default_instance_ && overall_support_ != NULL;
}
inline void Locus::clear_overall_support() {
  if (GetArenaNoVirtual() == NULL && overall_support_ != NULL) delete overall_support_;
  overall_support_ = NULL;
}
inline const ::vg::Support& Locus::overall_support() const {
  // @@protoc_insertion_point(field_get:vg.Locus.overall_support)
  return overall_support_ != NULL ? *overall_support_ : *default_instance_->overall_support_;
}
inline ::vg::Support* Locus::mutable_overall_support() {
  
  if (overall_support_ == NULL) {
    overall_support_ = new ::vg::Support;
  }
  // @@protoc_insertion_point(field_mutable:vg.Locus.overall_support)
  return overall_support_;
}
inline ::vg::Support* Locus::release_overall_support() {
  // @@protoc_insertion_point(field_release:vg.Locus.overall_support)
  
  ::vg::Support* temp = overall_support_;
  overall_support_ = NULL;
  return temp;
}
inline void Locus::set_allocated_overall_support(::vg::Support* overall_support) {
  delete overall_support_;
  overall_support_ = overall_support;
  if (overall_support) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:vg.Locus.overall_support)
}

// repeated double allele_log_likelihood = 6;
inline int Locus::allele_log_likelihood_size() const {
  return allele_log_likelihood_.size();
}
inline void Locus::clear_allele_log_likelihood() {
  allele_log_likelihood_.Clear();
}
inline double Locus::allele_log_likelihood(int index) const {
  // @@protoc_insertion_point(field_get:vg.Locus.allele_log_likelihood)
  return allele_log_likelihood_.Get(index);
}
inline void Locus::set_allele_log_likelihood(int index, double value) {
  allele_log_likelihood_.Set(index, value);
  // @@protoc_insertion_point(field_set:vg.Locus.allele_log_likelihood)
}
inline void Locus::add_allele_log_likelihood(double value) {
  allele_log_likelihood_.Add(value);
  // @@protoc_insertion_point(field_add:vg.Locus.allele_log_likelihood)
}
inline const ::google::protobuf::RepeatedField< double >&
Locus::allele_log_likelihood() const {
  // @@protoc_insertion_point(field_list:vg.Locus.allele_log_likelihood)
  return allele_log_likelihood_;
}
inline ::google::protobuf::RepeatedField< double >*
Locus::mutable_allele_log_likelihood() {
  // @@protoc_insertion_point(field_mutable_list:vg.Locus.allele_log_likelihood)
  return &allele_log_likelihood_;
}

// -------------------------------------------------------------------

// Genotype

// repeated int32 allele = 1;
inline int Genotype::allele_size() const {
  return allele_.size();
}
inline void Genotype::clear_allele() {
  allele_.Clear();
}
inline ::google::protobuf::int32 Genotype::allele(int index) const {
  // @@protoc_insertion_point(field_get:vg.Genotype.allele)
  return allele_.Get(index);
}
inline void Genotype::set_allele(int index, ::google::protobuf::int32 value) {
  allele_.Set(index, value);
  // @@protoc_insertion_point(field_set:vg.Genotype.allele)
}
inline void Genotype::add_allele(::google::protobuf::int32 value) {
  allele_.Add(value);
  // @@protoc_insertion_point(field_add:vg.Genotype.allele)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Genotype::allele() const {
  // @@protoc_insertion_point(field_list:vg.Genotype.allele)
  return allele_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Genotype::mutable_allele() {
  // @@protoc_insertion_point(field_mutable_list:vg.Genotype.allele)
  return &allele_;
}

// optional bool is_phased = 2;
inline void Genotype::clear_is_phased() {
  is_phased_ = false;
}
inline bool Genotype::is_phased() const {
  // @@protoc_insertion_point(field_get:vg.Genotype.is_phased)
  return is_phased_;
}
inline void Genotype::set_is_phased(bool value) {
  
  is_phased_ = value;
  // @@protoc_insertion_point(field_set:vg.Genotype.is_phased)
}

// optional double likelihood = 3;
inline void Genotype::clear_likelihood() {
  likelihood_ = 0;
}
inline double Genotype::likelihood() const {
  // @@protoc_insertion_point(field_get:vg.Genotype.likelihood)
  return likelihood_;
}
inline void Genotype::set_likelihood(double value) {
  
  likelihood_ = value;
  // @@protoc_insertion_point(field_set:vg.Genotype.likelihood)
}

// optional double log_likelihood = 4;
inline void Genotype::clear_log_likelihood() {
  log_likelihood_ = 0;
}
inline double Genotype::log_likelihood() const {
  // @@protoc_insertion_point(field_get:vg.Genotype.log_likelihood)
  return log_likelihood_;
}
inline void Genotype::set_log_likelihood(double value) {
  
  log_likelihood_ = value;
  // @@protoc_insertion_point(field_set:vg.Genotype.log_likelihood)
}

// optional double log_prior = 5;
inline void Genotype::clear_log_prior() {
  log_prior_ = 0;
}
inline double Genotype::log_prior() const {
  // @@protoc_insertion_point(field_get:vg.Genotype.log_prior)
  return log_prior_;
}
inline void Genotype::set_log_prior(double value) {
  
  log_prior_ = value;
  // @@protoc_insertion_point(field_set:vg.Genotype.log_prior)
}

// optional double log_posterior = 6;
inline void Genotype::clear_log_posterior() {
  log_posterior_ = 0;
}
inline double Genotype::log_posterior() const {
  // @@protoc_insertion_point(field_get:vg.Genotype.log_posterior)
  return log_posterior_;
}
inline void Genotype::set_log_posterior(double value) {
  
  log_posterior_ = value;
  // @@protoc_insertion_point(field_set:vg.Genotype.log_posterior)
}

// -------------------------------------------------------------------

// Support

// optional double quality = 1;
inline void Support::clear_quality() {
  quality_ = 0;
}
inline double Support::quality() const {
  // @@protoc_insertion_point(field_get:vg.Support.quality)
  return quality_;
}
inline void Support::set_quality(double value) {
  
  quality_ = value;
  // @@protoc_insertion_point(field_set:vg.Support.quality)
}

// optional double forward = 2;
inline void Support::clear_forward() {
  forward_ = 0;
}
inline double Support::forward() const {
  // @@protoc_insertion_point(field_get:vg.Support.forward)
  return forward_;
}
inline void Support::set_forward(double value) {
  
  forward_ = value;
  // @@protoc_insertion_point(field_set:vg.Support.forward)
}

// optional double reverse = 3;
inline void Support::clear_reverse() {
  reverse_ = 0;
}
inline double Support::reverse() const {
  // @@protoc_insertion_point(field_get:vg.Support.reverse)
  return reverse_;
}
inline void Support::set_reverse(double value) {
  
  reverse_ = value;
  // @@protoc_insertion_point(field_set:vg.Support.reverse)
}

// optional double left = 4;
inline void Support::clear_left() {
  left_ = 0;
}
inline double Support::left() const {
  // @@protoc_insertion_point(field_get:vg.Support.left)
  return left_;
}
inline void Support::set_left(double value) {
  
  left_ = value;
  // @@protoc_insertion_point(field_set:vg.Support.left)
}

// optional double right = 5;
inline void Support::clear_right() {
  right_ = 0;
}
inline double Support::right() const {
  // @@protoc_insertion_point(field_get:vg.Support.right)
  return right_;
}
inline void Support::set_right(double value) {
  
  right_ = value;
  // @@protoc_insertion_point(field_set:vg.Support.right)
}

// -------------------------------------------------------------------

// Translation

// optional .vg.Path from = 1;
inline bool Translation::has_from() const {
  return !_is_default_instance_ && from_ != NULL;
}
inline void Translation::clear_from() {
  if (GetArenaNoVirtual() == NULL && from_ != NULL) delete from_;
  from_ = NULL;
}
inline const ::vg::Path& Translation::from() const {
  // @@protoc_insertion_point(field_get:vg.Translation.from)
  return from_ != NULL ? *from_ : *default_instance_->from_;
}
inline ::vg::Path* Translation::mutable_from() {
  
  if (from_ == NULL) {
    from_ = new ::vg::Path;
  }
  // @@protoc_insertion_point(field_mutable:vg.Translation.from)
  return from_;
}
inline ::vg::Path* Translation::release_from() {
  // @@protoc_insertion_point(field_release:vg.Translation.from)
  
  ::vg::Path* temp = from_;
  from_ = NULL;
  return temp;
}
inline void Translation::set_allocated_from(::vg::Path* from) {
  delete from_;
  from_ = from;
  if (from) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:vg.Translation.from)
}

// optional .vg.Path to = 2;
inline bool Translation::has_to() const {
  return !_is_default_instance_ && to_ != NULL;
}
inline void Translation::clear_to() {
  if (GetArenaNoVirtual() == NULL && to_ != NULL) delete to_;
  to_ = NULL;
}
inline const ::vg::Path& Translation::to() const {
  // @@protoc_insertion_point(field_get:vg.Translation.to)
  return to_ != NULL ? *to_ : *default_instance_->to_;
}
inline ::vg::Path* Translation::mutable_to() {
  
  if (to_ == NULL) {
    to_ = new ::vg::Path;
  }
  // @@protoc_insertion_point(field_mutable:vg.Translation.to)
  return to_;
}
inline ::vg::Path* Translation::release_to() {
  // @@protoc_insertion_point(field_release:vg.Translation.to)
  
  ::vg::Path* temp = to_;
  to_ = NULL;
  return temp;
}
inline void Translation::set_allocated_to(::vg::Path* to) {
  delete to_;
  to_ = to;
  if (to) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:vg.Translation.to)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace vg

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::vg::SnarlType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vg::SnarlType>() {
  return ::vg::SnarlType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_vg_2eproto__INCLUDED
